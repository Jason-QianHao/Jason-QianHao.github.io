---
title: 华为
tags: 笔经面经
---

# 华为

我是2021-06-16投递的华为FX提前批：

- 软件开发工程师

- (领域)通用软件开发工程师

- (第一意向部门)公共开发部

- (第二意向部门)消费者云服务部

## 笔试

​	之前就通知今天（2021-07-07）笔试，不过直到今天上午才发的笔试邮件，晚上19点笔试。

​	笔试内容就3道编程题，120分钟

1. 第一题是场景题。共100分

   > SLA是接受订单起，到维修完的最大要求时间。从某时刻起计算给定的订单的最大积分。
   
   | 编号 | SLA  | 积分 |
   | ---- | ---- | ---- |
   | 1    | 1    | 4    |
   | 2    | 1    | 5    |
   | 3    | 2    | 7    |
   
   我写的是贪心，积分最大排序，然后按照时间去做，只通过25%。
   
2. 第二题是图论的题目。共200分

   > 通过场景给定一个有向带权图，给定初始点，问是否可以便利到所有点，若能便利，那么最长路径是多少。

   这一题，我在IDE上调试了，所以代码也保存下来了。基本思路就是建图+dfs遍历。通过率100%

   ```java
   import java.util.*;
   
   public class FX {
       private static int[][] edges;
       private static Set<Integer> nodeSet = new HashSet();
       private static Set<Integer> isVisited = new HashSet();
       private static Queue<Integer> q = new LinkedList();
       private static int maxlen = 0;
       public static void main(String[] args){
       	/*
       	 *  [1,2,15]
   			[1,3,7]
   			[3,4,9]
   			4
   			1
       	 */
           Scanner sc = new Scanner(System.in);
           List<String> list = new ArrayList();
           String sin = "";
           while(sc.hasNext()){
           	sin = sc.nextLine();
           	sin = sin.trim();
   //            System.out.println(s);
               if(sin.charAt(0) != '['){
                   break;
               }
               list.add(sin);
           }
           int N = Integer.valueOf(sin);
           int S = Integer.valueOf(sc.nextLine());
           edges = new int[N + 1][N + 1];
           for(String s : list){
               int[] tmp = stringToArray(s);
               insertEdge(tmp[0], tmp[1], tmp[2]);
               nodeSet.add(tmp[0]);
               nodeSet.add(tmp[1]);
           }
           dfs(S, 0);
           if(isVisited.size() != nodeSet.size()){
               System.out.println(-1);
           }else {
           	System.out.println(maxlen);
           }
       }
       
       public static int[] stringToArray(String s){
           s = s.trim();
           s = s.substring(1, s.length() - 1);
           String[] strs = s.split(",");
           int[] out = new int[strs.length];
           for(int i = 0; i < out.length; i++){
               out[i] = Integer.valueOf(strs[i].trim());
           }
           return out;
       }
       
       public static void insertEdge(int a, int b, int pathw){
           edges[a][b] = pathw;
       }
       
       public static List<Integer> getNeighbor(int a){
           List<Integer> res = new ArrayList();
           for(int i : nodeSet){
               if(edges[a][i] > 0){
                   res.add(i);
               }
           }
           return res;
       }
       
       public static void dfs(int S, int path){
           if(isVisited.contains(S)){
               return;
           }
           maxlen = Math.max(maxlen, path);
           isVisited.add(S);
           for(int i : getNeighbor(S)){
               if(!isVisited.contains(i)){
                   path += edges[S][i];
                   dfs(i, path);
                   path -= edges[S][i];
               }
           }
       }
   }
   
   ```

3. 第三题是二维数组的搜索。共300分

   > 象棋背景下，给定起始点，给定终点，棋盘上还有其他子，还有用“马”的方式跳跃（有约束条件）。问能否到终点，能到的话，最少跳跃步数是多少？

   这题我的思路是类似于leetcode的单词搜索，但是做题的时候只剩40分钟了，来不及调试，代码超出时间限制，后面有时间好好找找原因，所以这题没有通过。下面是**没有通过**的代码，记录一下，后面再查一下。

   >import java.util.*;
   >
   >public class FX2 {
   >	/*
   >	 * 5 13
   >	........H...#
   >	........#....
   >	.....#.......
   >	.#...........
   >	..........T#.
   >	 */
   >    static int w, h;
   >    static int[][] direction = new int[][]{{-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}};
   >    static int[][] dangers = new int[][]{{0, -1}, {-1, 0}, {-1, 0}, {0, 1}, {0, 1}, {1, 0}, {1, 0}, {0, -1}};
   >    static boolean[][] used;
   >    static boolean flag = false;
   >    static int minStep = Integer.MAX_VALUE;
   >    static List<int[]> others;
   >    public static void main(String[] args){
   >        Scanner sc = new Scanner(System.in);
   >        w = sc.nextInt();
   >        h = sc.nextInt();
   >        used = new boolean[w][h];
   >        String s = sc.nextLine();
   >        System.out.print(s);
   >        char[][] chess = new char[w][h];
   >        int[] H = new int[2];
   >        int[] T = new int[2];
   >        others = new ArrayList();
   >        for(int i = 0; i < w; i++){
   >            s = sc.nextLine();
   >            s = s.trim();
   >            for(int j = 0; j < s.length(); j++){
   >                chess[i][j] = s.charAt(j);
   >                if(chess[i][j] == 'H'){
   >                    H[0] = i;
   >                    H[1] = j;
   >                }else if(chess[i][j] == 'T'){
   >                    T[0] = i;
   >                    T[1] = j;
   >                }else if(chess[i][j] == '#'){
   >                    others.add(new int[]{i, j});
   >                }
   >            }
   >        }
   >        dfs(chess, H[0], H[1], T, 0);
   >        if(!flag){
   >            System.out.println(-1);
   >        }else {
   >            System.out.println(minStep);
   >        }
   >    }
   >
   >    public static void dfs(char[][] chess, int x, int y, int[] T, int step){
   >//    	System.out.println(x + "  " + y);
   >        if(x == T[0] && y == T[1]){
   >            flag = true;
   >            minStep = Math.min(minStep, step);
   >            return;
   >        }
   >        used[x][y] = true;
   >        for(int i = 0; i < 8; i++){
   >            int nextx = x + direction[i][0];
   >            int nexty = y + direction[i][1];
   >            if(isValid(nextx, nexty) && !used[nextx][nexty] && !isDanger(nextx, nexty)){
   >                step++;
   >                dfs(chess, nextx, nexty, T, step);
   >                step--;
   >            }
   >        }
   >        used[x][y] = false;
   >    }
   >    
   >
   >    public static boolean isValid(int x, int y){
   >        return x >= 0 && x < w && y >= 0 && y < h;
   >    }
   >    
   >    public static boolean isDanger(int x, int y){
   >        for(int i = 0; i < 8; i++){
   >            if(dangers[i][0] == x && dangers[i][1] == y){
   >                return true;
   >            }
   >        }
   >        for(int[] n : others) {
   >        	if(n[0] == x && n[1] == y) {
   >        		return true;
   >        	}
   >        }
   >        return false;
   >    }
   >}

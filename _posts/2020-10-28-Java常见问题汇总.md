---
title: Java场景问题汇总
tags: Java
---

*由简书搬迁而来[**原文链接**](https://www.jianshu.com/p/0818149b58f5)*

> 目录  
> **常见问题汇总**  
> 
> 参考资料  
> ·《Java编程思想》  
> ·《Java Web 技术内幕》  
>·《Java 并发编程实战》  

# 常见问题汇总

## 项目打成jar包后，读取资源文件

```java
 //源代码1： 
 package edu.hxraid; 
 import java.io.*; 
 public class Resource { 
   public void getResource() throws IOException{ 
    File file=new File("bin/resource/res.txt"); 
    BufferedReader br=new BufferedReader(new FileReader(file)); 
    String s=""; 
    while((s=br.readLine())!=null) 
      System.out.println(s); 
   } 
}  
```

  **打成jar包运行时爆错！**

  因为jar包是一个单独的文件而非文件夹，绝对不可能通过"file:/e:/.../ResourceJar.jar/resource /res.txt"这种形式的文件URL来定位res.txt。所以即使是相对路径，也无法定位到jar文件内的txt文件(读者也许对这段原因解释有些费解，在下面我们会用一段代码运行的结果来进一步阐述)。

我们可以用类装载器(ClassLoader)来做到这一点：

**(1) ClassLoader 是类加载器的抽象类。它可以在运行时动态的获取加载类的运行信息。** 可以这样说，当我们调用ResourceJar.jar中的Resource类时，JVM加载进Resource类，并记录下Resource运行时信息(包括Resource所在jar包的路径信息)。而ClassLoader类中的方法可以帮助我们动态的获取这些信息:

● public URL getResource(String name)

查找具有给定名称的资源。资源是可以通过类代码以与代码基无关的方式访问的一些数据(图像、声音、文本等)。并返回资源的URL对象。

● public InputStream getResourceAsStream(String name);

返回读取指定资源的输入流。这个方法很重要，可以直接获得jar包中文件的内容。

**(2)** ClassLoader是abstract的，不可能实例化对象，更加不可能通过ClassLoader调用上面两个方法。**所以我们真正写代码的时候，是通过Class类中的getResource()和getResourceAsStream()方法，这两个方法会委托ClassLoader中的getResource()和getResourceAsStream()方法** 。好了，现在我们重新写一段Resource代码,来看看上面那段费解的话是什么意思了：

```java
 //源代码2： 
 package edu.hxraid; 
 import java.io.*; 
 import java.net.URL; 
 public class Resource { 
     public void getResource() throws IOException{  
     //查找指定资源的URL，其中res.txt仍然开始的bin目录下  
        URL fileURL=this.getClass().getResource("/resource/res.txt");  
        System.out.println(fileURL.getFile()); 
       } 

     public static void main(String[] args) throws IOException { 
        Resource res=new Resource(); 
        res.getResource(); 
     } 
  } 
```

运行这段源代码结果：/E:/Code_Factory/WANWAN/bin/resource/res.txt (../ Code_Factory/WANWAN/.. 是java project所在的路径)

 我们将这段代码打包成ResourceJar.jar ,并将ResourceJar.jar放在其他路径下(比如 c:\ResourceJar.jar)。然后另外创建一个java project并导入ResourceJar.jar，写一段调用jar包中Resource类的测试代码：

```java
 import java.io.IOException; 
 import edu.hxraid.Resource; 
 public class TEST { 
     public static void main(String[] args) throws IOException { 
     	Resource res=new Resource(); 
        res.getResource(); 
     } 
 } 
```

 这时的运行结果是：file:/C:/ResourceJar.jar!/resource/res.txt

 我们成功的在运行时动态获得了res.txt的位置。然而，问题来了，你是否可以通过下面这样的代码来得到res.txt文件？

File f=new File("C:/ResourceJar.jar!/resource/res.txt");

当然不可能，因为".../ResourceJar.jar!resource/...."并不是文件资源定位符的格式 (jar中资源有其专门的URL形式：

**jar:<url>!/{entry}**)。所以，如果jar包中的类源代码用File f=new File(相对路径);的形式，是不可能定位到文件资源的。这也是为什么源代码打包成jar文件后，调用jar包时会报出FileNotFoundException的症结所在了。

**(3)** 我们不能用常规操作文件的方法来读取ResourceJar.jar中的资源文件res.txt，**但可以通过Class类的getResourceAsStream()方法来获取** ，这种方法是如何读取jar中的资源文件的，这一点对于我们来说是透明的。我们将Resource.java改写成：

```java
 //源代码3： 
 package edu.hxraid; 
 import java.io.*; 
 public class Resource { 
     public void getResource() throws IOException{ 
         //返回读取指定资源的输入流 
         InputStream is=this.getClass().getResourceAsStream("/resource/res.txt");  
         BufferedReader br=new BufferedReader(new InputStreamReader(is)); 
         String s=""; 
         while((s=br.readLine())!=null) 
              System.out.println(s); 
     } 
 } 
```

  我们将java工程下/bin目录中的edu/hxraid/Resource.class和资源文件resource/res.txt一并打包进ResourceJar.jar中，不管jar包在系统的任何目录下，调用jar包中的Resource类都可以获得jar包中的res.txt资源，再也不会找不到res.txt文件了。

## java运行jar命令提示没有主清单属性

（1）在java中编译JAR文件的时候我们都会用到，jar这个命令。

（2）这样的问题是因为，jar包中的**META-INF**文件夹下的**MANIFEST.MF**文件缺少定义jar接口类。**说白了就是没有指定class类**。这里说明一下MANIFEST.MF就是一个清单文件，

通俗点将就相当于WINDOWS中ini配置文件。用来配置程序的一些信息。

（3）解决这个问题的方法就是要在**MANIFEST.MF**文件中添加一个入口类。

即需要一个Main-Class定义行。更详细的MANIFEST.MF文件定义说明，请参考官方MANIFEST.MF文件定义手册。

详见：[java运行jar命令提示没有主清单属性 - shaomine - 博客园](https://www.cnblogs.com/shaosks/p/9984350.html)

## java中获取各种上下文路径的方法小结

详见：[java中获取各种上下文路径的方法小结 - shawWey - 博客园](https://www.cnblogs.com/shawWey/p/6897377.html)

## Swtich和Map的性能对比

  JVM对使用switch实现的方法并没有被优化，优化全部是针对Map,Integer等进行的，也就是说在使用map的实现中，大量地利用了JIT的本地优化代码；而switch的实现以jvm指令的形式执行，这样解释了为什么在这个测试中map在启用JIT的情况下，会比switch快一倍左右;而禁用JIT以后，会慢10倍左右。

## java.io几种读写文件的方式

详见：[java.io几种读写文件的方式 - 小不点丶 - 博客园](https://www.cnblogs.com/ll409546297/p/7197911.html)

## Java集成matlab

详见：[JAVA调用matlab代码 - winvv - 博客园](https://www.cnblogs.com/winv758241/p/7744383.html)

常见错误：[java matlab 混合编程 Failed to find the required library mclmcrrt9_2.dll on java.library.path._weixin_30247307的博客-CSDN博客](https://blog.csdn.net/weixin_30247307/article/details/99599788)

## Java 中初始化 List 集合的 6 种方式

详见：[Java 中初始化 List 集合的 6 种方式! - 知乎](https://zhuanlan.zhihu.com/p/51742171)

https://blog.csdn.net/u012448083/article/details/75026310)

## 遍历Map集合

普遍使用，二次取值

System.out.println("通过Map.keySet遍历key和value：");

for (String key : map.keySet()) {

System.out.println("key= "+ key + " and value= " + map.get(key));

}

详见：[遍历Map - 知乎](https://zhuanlan.zhihu.com/p/76642935)

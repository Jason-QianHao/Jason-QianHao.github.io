---
title: 华为
tags: 笔经面经
---

# 华为

我是2021-06-16投递的华为FX提前批：

- 软件开发工程师

- (领域)通用软件开发工程师

- (第一意向部门)公共开发部

- (第二意向部门)消费者云服务部

## 笔试

​	之前就通知今天（2021-07-07）笔试，不过直到今天上午才发的笔试邮件，晚上19点笔试。

​	笔试内容就3道编程题，120分钟

1. 第一题是场景题。共100分

   > SLA是接受订单起，到维修完的最大要求时间。从某时刻起计算给定的订单的最大积分。
   
   | 编号 | SLA  | 积分 |
   | ---- | ---- | ---- |
   | 1    | 1    | 4    |
   | 2    | 1    | 5    |
   | 3    | 2    | 7    |
   
   我写的是贪心，积分最大排序，然后按照时间去做，只通过25%。
   
2. 第二题是图论的题目。共200分

   > 通过场景给定一个有向带权图，给定初始点，问是否可以便利到所有点，若能便利，那么最长路径是多少。

   这一题，我在IDE上调试了，所以代码也保存下来了。基本思路就是建图+dfs遍历。通过率100%

   ```java
   import java.util.*;
   
   public class FX {
       private static int[][] edges;
       private static Set<Integer> nodeSet = new HashSet();
       private static Set<Integer> isVisited = new HashSet();
       private static Queue<Integer> q = new LinkedList();
       private static int maxlen = 0;
       public static void main(String[] args){
       	/*
       	 *  [1,2,15]
   			[1,3,7]
   			[3,4,9]
   			4
   			1
       	 */
           Scanner sc = new Scanner(System.in);
           List<String> list = new ArrayList();
           String sin = "";
           while(sc.hasNext()){
           	sin = sc.nextLine();
           	sin = sin.trim();
   //            System.out.println(s);
               if(sin.charAt(0) != '['){
                   break;
               }
               list.add(sin);
           }
           int N = Integer.valueOf(sin);
           int S = Integer.valueOf(sc.nextLine());
           edges = new int[N + 1][N + 1];
           for(String s : list){
               int[] tmp = stringToArray(s);
               insertEdge(tmp[0], tmp[1], tmp[2]);
               nodeSet.add(tmp[0]);
               nodeSet.add(tmp[1]);
           }
           dfs(S, 0);
           if(isVisited.size() != nodeSet.size()){
               System.out.println(-1);
           }else {
           	System.out.println(maxlen);
           }
       }
       
       public static int[] stringToArray(String s){
           s = s.trim();
           s = s.substring(1, s.length() - 1);
           String[] strs = s.split(",");
           int[] out = new int[strs.length];
           for(int i = 0; i < out.length; i++){
               out[i] = Integer.valueOf(strs[i].trim());
           }
           return out;
       }
       
       public static void insertEdge(int a, int b, int pathw){
           edges[a][b] = pathw;
       }
       
       public static List<Integer> getNeighbor(int a){
           List<Integer> res = new ArrayList();
           for(int i : nodeSet){
               if(edges[a][i] > 0){
                   res.add(i);
               }
           }
           return res;
       }
       
       public static void dfs(int S, int path){
           if(isVisited.contains(S)){
               return;
           }
           maxlen = Math.max(maxlen, path);
           isVisited.add(S);
           for(int i : getNeighbor(S)){
               if(!isVisited.contains(i)){
                   path += edges[S][i];
                   dfs(i, path);
                   path -= edges[S][i];
               }
           }
       }
   }
   
   ```

3. 第三题是二维数组的搜索。共300分

   > 象棋背景下，给定起始点，给定终点，棋盘上还有其他子，还有用“马”的方式跳跃（有约束条件）。问能否到终点，能到的话，最少跳跃步数是多少？

   这题我的思路是类似于leetcode的单词搜索，但是做题的时候只剩40分钟了，来不及调试，代码超出时间限制，后面有时间好好找找原因，所以这题没有通过。
   
   问题找到了，主要是**剪枝和回溯return位置**的问题。
   
   <img src="/../assets/Exam/6650D184-903C-4B96-955F-E5ED30E37ED8_1_105_c.jpeg" style="zoom:50%;" />

<img src="/../assets/Exam/8D6C60CC-29B1-4E15-B0AD-1BC4D897EE73.png" style="zoom:50%;" />

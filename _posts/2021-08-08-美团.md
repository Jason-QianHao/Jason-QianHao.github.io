---
title: 美团
tags: 笔经面经
---

# 美团

我是2021-08-02投递：

- 申请职位：后端开发工程师

- 工作城市：上海市

- 面试城市：上海市

- 感兴趣事业群：都喜欢

## 笔试

​	2021-08-06收到笔试链接，周日(2021-08-08)笔试。

​	一共4+1道编程题，分在线编程和专项编程，2个小时

1. 给定n个数，在1-n范围内，问能否在1-n中找到一个数x，使得n个数中恰好有k个数小于x。

   还算简单，通过率100%

   ```java
   public static void main(String[] args){
   	        Scanner sc = new Scanner(System.in);
   	        int T = sc.nextInt();
   	        while(T-- > 0){
   	            int n = sc.nextInt();
   	            int k = sc.nextInt();
   	            Queue<Integer> q = new PriorityQueue();
   	            for(int i = 0; i < n; i++){
   	                q.offer(sc.nextInt());
   	            }
   	            int pre = 0;
   	            while(k-- > 0){
   	                pre = q.poll();
   	            }
   	            if(!q.isEmpty()){
   	                if(pre == q.peek()){
   	                    System.out.println("NO");
   	                    continue;
   	                }
   	            }
   	            if(pre + 1 > n){
   	                System.out.println("NO");
   	                continue;
   	            }
   	            System.out.println("YES");
   	            System.out.println(pre + 1);
   	        }
   	    }
   ```

   

2. 一个情景题，概括起来就是对给定字符串去重和去空格。

   通过率100%；

   ```java 
   public static void main(String[] args){
           Scanner sc = new Scanner(System.in);
           String s = sc.nextLine();
           s = s.trim();
           if(s.length() == 0){
               System.out.println("");
               return;
           }
           char pre = s.charAt(0);
           StringBuffer res = new StringBuffer();
           res.append(pre);
           for(int i = 1; i < s.length(); i++){
               char c = s.charAt(i);
               if(c == ' ' || c == pre){
                   continue;
               }
               pre = c;
               res.append(pre);
           }
           System.out.println(res.toString());
       }
   ```

   

3. 给定一个数组，求每个数前面数中，比它小的最大值，最后再进行运算。

   题意简单，但是可能对复杂度要求要尽量低，只通过64%。想过几种办法，都是一样，想着用单调栈，但是感觉行不通。

   ```java
   public static void main(String[] args){
           Scanner sc = new Scanner(System.in);
           int n = sc.nextInt();
           int[] arr = new int[n];
           int[] prev = new int[n];
           for(int i = 0; i < n; i++){
               arr[i] = sc.nextInt();
               int t = i;
               for(int j = i - 1; j >= 0; j--) {
               	if(arr[j] > arr[t]) {
               		swap(arr, j, t);
                       t = j;
               	}else if(arr[j] == arr[t]){
                       continue;
                   }else {
                       prev[i] = arr[j];
                       break;
                   }
               }
               System.out.print(prev[i] + " ");
           }
           long res = 0;
           for(int i = 0; i < n; i++){
               res += prev[i] * (i + 1);
           }
           System.out.println(res);
       }
       
       public static void swap(int[] nums, int a, int b){
           int tmp = nums[a];
           nums[a] = nums[b];
           nums[b] = tmp;
       }
   ```

   

4. 将一个数组，前面一半和后面一半用最少的替换方法使其一直。对每个x替换成y，数组中所有x都变成y。

   最后通过27%。也是因为时间复杂度的问题，但没时间优化了。

   ```java
   public static void main(String[] args){
           Scanner sc = new Scanner(System.in);
           int n = sc.nextInt();
           int[] arr = new int[n];
           for(int i = 0; i < n; i++){
               arr[i] = sc.nextInt();
           }
           // 第一次遍历，找不同
           List<int[]> list = new ArrayList();
           for(int i = 0; i < n/ 2; i++){
               if(arr[i] != arr[i + n / 2]){
                   list.add(new int[]{arr[i], arr[i + n / 2]});
               }
           }
           if(list.size() <= 1){
               System.out.println(list.size());
               return;
           }
           int cnt = 0;
   //        cnt++;
   //        update(list, list.get(0));
   //        continue;
           while(!list.isEmpty()){
           	int[] i = list.get(0);
               cnt++;
               update(list, i);
           }
   		System.out.println(cnt);
       }
       
       public static void update(List<int[]> list, int[] nums){
       	for(int[] i : list){
               if(i[0] == nums[0]){
                   i[0] = nums[1];
               }else if(i[1] == nums[0]){
                   i[1] = nums[1];
               }
               if(i[0] == i[1]) {
               	list.remove(i);
               }
           }
       }
   ```

   

5. 通过输入建立一棵树，然后会对一些节点的左右子树进行交换，对交换后的树，中序遍历。

   难度也还行，就是建立树的时候想了一下。

   ```java
   import java.util.*;
   
   class TreeNode {
       int code;
       TreeNode left;
       TreeNode right;
       public TreeNode(int code){
           this.code = code;
       }
   }
   
   public class Test5 {
   
   	public static void main(String[] args){
           Scanner sc = new Scanner(System.in);
           int n = sc.nextInt();
           int m = sc.nextInt();
           int k = sc.nextInt();
           Map<Integer, TreeNode> map = new HashMap();
           for(int i = 1; i <= n; i++){
               map.put(i, new TreeNode(i));
           }
           for(int i = 1; i <= n; i++){
               TreeNode node = map.get(i);
               int l = sc.nextInt();
               int r = sc.nextInt();
               if(l != 0){
                   node.left = map.get(l);
               }
               if(r != 0){
                   node.right = map.get(r);
               }
           }
           for(int i = 0; i < m; i++){
               int top = sc.nextInt();
               TreeNode node = map.get(top);
               dfs(node);
           }
           List<Integer> list = new ArrayList();
           Stack<TreeNode> st = new Stack();
           TreeNode root = map.get(k);
           while(!st.isEmpty() || root != null){
               while(root != null){
                   st.push(root);
                   root = root.left;
               }
               root = st.pop();
               list.add(root.code);
               root = root.right;
           }
           for(int i : list){
               System.out.print(i + " ");
           }
           System.out.println();
       }
       
       public static void dfs(TreeNode node){
           if(node == null){
               return;
           }
           TreeNode tmp = node.left;
           node.left = node.right;
           node.right = tmp;
   //        dfs(node.left);
   //        dfs(node.right);
       }
   }
   
   ```


## 一面

2021-08-16（周一）收到一面的面试邮件，2021-08-20（周五）进行面试。

面试大概40分钟左右～

面试官小哥哥也是南大的，人非常好。

### 面试官自我介绍

介绍了这是“大众点评”部门。

### 自我介绍

Skip...

### 知识点

1. 介绍一下实验室的数字9宫格项目。

   回答了项目背景、系统介绍，加入了服务器端端介绍。

2. 面试官问项目里面几个处理部分是怎么设计的？

   回答了多线程设计，并用CountDownLatch进行线程同步。

   面试官追问，客户端一直等待吗？

   回答了，线程设计的另一方面的作用就是给客户端发送提示信息。**这里后面可以回答，目前简单给了客户端一个提示信息，然后js向服务器获取文件。后面可以利用js定时发送一个请求给服务器，判断是否训练已经完成。**

3. 看过CountDownLatch的源码吗？

   回答了具体代码没看，知道是用AQS实现的。

   面试官追问AQS的实现原理？

   回答了state和CLH。

4. CAS和阻塞有什么利弊？

   回答了可以说是乐观锁与悲观锁的区别，乐观锁在读写并发方面优于悲观锁。

5. 线程安全有什么作用？

   回答了一个例子，两个线程同时修改一个变量，会有问题。

6. volatile对变量的++操作有什么影响？

   回答了除了保证可见性，也禁止了重排序。

   面试官追问，那用volatile修饰的变量，可以++吗？

   回答了最好不要吧，可以使用原子类。

7. synchronized的底层原理？

   回答了同步方法和同步代码块的底层实现。

8. 了解raft算法吗？

   回答了是分布式的选举算法吗？

   面试官说是的，回答一下zk的选举算法。

   回答了选票的构成，选举的过程。

9. 为什么redis的slot划分为16384？

   回答了节点间通信信息传递数据量的因素。

10. hashmap线程安全吗？为什么不安全？

    回答了不安全，在rehash的时候，后面的链表可能有死循环。

### 算法

1. 题目：二叉树搜索树的最小差值。

   Leetcode原题：

   ```java
   private static int minres = Integer.MAX_VALUE;
       private static TreeNode prev = null;
       public static int findMin(TreeNode root) {
           if(root == null){
               return 0;
           }
           dfs(root);
           return minres;
       }
       // 1 2 3 4 5
       //  1 1+x
       public static void dfs(TreeNode root){
           if(root == null){
               return;
           }
           dfs(root.left);
           if(prev != null){
               minres = Math.min(minres, root.val - prev.val);
           }
           prev = root;
           dfs(root.right);
       }
   ```

2. 题目：联表查询

   对面试官说常用了单表查询，所以试一下

   ```mysql
   /*
   StudentId | Grade | Gender （1男生 2女生） | IsValid（0：已毕业 1：在读）
   
   StudentId | BookId | Status（0：已归还 1：在借）
   
   统计二年级女同学每个人在借图书的数量
   */
   
   select count(BookId) from B where StudentId in (
           select StudentId from A where Grade=2 and Gender=2) group by StudentId;
   # 面试官问如果不用子查询，用Join on用哪个
   # 回答了，是交集，直接用join on即可
           (inner) join on
           outter left join on ..
   ```

### 反问

1. 问了具体我可能负责的业务，办公地点

   面试官说具体要等进来了才知道，办公地点在虹桥附近。

2. 面试官问面试其他公司的情况？怎么选择？

   我说了有了字节的offer。

   选择的话，我说字节用go，你们用java，然后是大众点评的部门，业务也不错，肯定多多考虑。

## 二面

2021-08-23（周一）收到二面的邀约电话和邮件，2021-08-24（周二）进行面试。

面试大概1小时左右～

面试官也非常的温柔。

### 与我相关

1. 在本科和研究生期间的排名

   回答了本科5%，研究生10-20%左右。

2. 家是哪里的？

   回答了安徽，但是常住上海。

3. 问了offer的对比？

   和前面的回答一致。

### 项目

1. 介绍一下实验室的项目和软件的项目。

   回答了数字9宫格和电商网站。

2. 电商网站的功能介绍的代码介绍

3. 系统是怎么做到对用户登陆状态的判定的？

   更好的是拿用户的openid直接作为Redis的key，判断是否为null。

   20210825 已更新相关内容在Shop博客说明这个问题。

4. 博客什么时候写的，有哪些内容？

   答了从简书搬迁过来，后续会补充自己喜欢的东西。

5. github的项目简单聊了聊

### 算法

- 题目：数组中连续递增的子数组。

  leetcode原题。

### 反问

- 后面的面试安排是怎样的？

  面试官说三轮技术面+hr面

## 三面

2021-08-26（周四）收到三面的邀约电话和邮件，2021-08-30（周一）进行面试。

面试大概1小时左右～

面试官非常的和蔼，婉婉道来。

### 自我介绍

Skip...

1. 介绍一下实验室和你自己的方向

   回答了实验室的基本构成，和自己转软件开发的过程。

2. 怎么学习和实现实验室功能的？

   回答了自己的学习过程。

### 项目

1. tomcat工程中的web.xml配置文件了解吗？

   回答了是配置映射路径的文件。

   面试官追问知道什么时候加载和使用它吗？

   回答了启动的时候会检查web.xml文件，其他的自己理解，。。

   面试官说，不要猜。。

2. 为什么会有这两个软件项目？和别人有什么不同？

   这里开始和面试官小小的辩论了，说了自己不是为了面试而面试吧，没看过别人的简历，所以不能说不同。就介绍了自己写项目的背景和过程。

   面试官问写完后的收获？

   回答了熟悉后端开发，和自信心。

3. 写项目过程中怎么解决问题的？

   回答了从日志开始一步步过来，举例了fegin调用过程中@RestController误写为@Controller导致的报错...

### 其他

1. 对找工作的理解和要求？

   回答了岗位匹配、业务发展、地点、薪资。

### 反问

1. 业务？

   面试官说变动很快，暂时我了解到的已经差不多了。

2. 和面试官聊了关于美团的一些信息，然后面试官评价我“沟通能力已经非常出色了”。

## hr面

2021-08-31（周二）收到hr面的邀约电话和邮件，2021-09-01（周三）进行面试。

面试大概30分钟左右。

小姐姐人非常温柔～

### 自我介绍

Skip...

### 个人经历

1. 问在项目和学习中的困难

2. 面对压力是怎么解决的

3. 参加过学生工作吗？

   回答了本科时的秘书处。

   hr追问当时是干了什么有什么收获？

   回答了采访毕业生的事情。

4. 社交方面对自己的影响

5. 平时怎么学习和安排生活的。

   回答了按计划

6. 对职业的规划？

   回答了10年后想转架构师，然后业务上多学习划分。

7. 对美团app使用过程中，觉得有什么优缺点？

   回答了ui交互设计的很喜欢，没有弹窗广告，外卖推送菜很合胃口，缺点说了支付完成后需要用户点击确认。

8. offer的对比

## offer

2021-09-02（周四）收到意向书offer～

---
title: Go学习笔记
tags: Go
---

# Go学习笔记

# 概念

- Go 是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易。

- Go 语言被设计成一门**应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言**。对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。

- 语言特色
  - 简洁、快速、安全
  - 并行、有趣、开源
  - 内存管理、数组安全、编译迅速

# 基本语法

## 语法结构

- 包含

  - 包声明

    必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。

  - 引入包

  - 函数

  - 变量

  - 语句 & 表达式

    当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）

  - 注释

  ```go
  // demo
  package main
  
  import "fmt"
  
  func main() {
     /* 这是我的第一个简单的程序 */
     fmt.Println("Hello, World!")
  }
  ```

- 运行

  - *go run hello.go*运行文件
  - **go build** hello.go命令来生成二进制文件（可执行文件）

  ```go
  $ go build hello.go 
  $ ls
  hello    hello.go
  $ ./hello 
  Hello, World!
  ```

- 行分隔符
  在 Go 程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。

  如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。
  
- 格式化输出

  Go 语言中使用 **fmt.Sprintf** 格式化字符串并赋值给新串：

  ```go
  package main
  
  import (
      "fmt"
  )
  
  func main() {
     // %d 表示整型数字，%s 表示字符串
      var stockcode=123
      var enddate="2020-12-31"
      var url="Code=%d&endDate=%s"
      var target_url=fmt.Sprintf(url,stockcode,enddate)
      fmt.Println(target_url)
  }
  
  // output: Code=123&endDate=2020-12-31
  ```

## 数据类型

### 分类

| 序号 | 类型和描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | **布尔型** <br />布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。 |
| 2    | **数字类型** <br />整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。<br />Go 也有基于架构的类型，例如：int8、uint8 等 |
| 3    | **字符串类型:** <br />- 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。<br />- **Go 语言的字符串可以通过 “+”实现** |
| 4    | **派生类型:** <br />(a) 指针类型（Pointer）<br />(b) 数组类型<br />(c) 结构化类型(struct)<br />(d) Channel 类型<br />(e) 函数类型<br />(f) 切片类型<br />(g) 接口类型（interface）<br />(h) Map 类型 |

详细参考：[go数据类型](https://www.runoob.com/go/go-data-types.html)

### 变量

声明变量的一般形式是使用` var` 关键字：`var identifier1, identifier2 type`

```go
// demo
package main
import "fmt"
func main() {
    var a string = "Runoob"
    fmt.Println(a)

    var b, c int = 1, 2
    fmt.Println(b, c)
}
```

声明变量有以下几种方式：

- **指定变量类型，如果没有初始化，则变量默认为零值**。

```go
//var v_name v_type
//v_name = value
// 没有初始化就为零值
var b int
```

- **根据值自行判定变量类型。**

```go
// var v_name = value
var d = true
```

- **使用 \**:=\** 声明变量**(使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值)

`intVal := 1 `相等于：

```go
var intVal int 
intVal =1 
```

 出现在 `:= `左侧的变量不应该是已经被声明过的，否则会导致编译错误

- 因式分解法(一般用于声明全局变量)

  ```go
  var (
      vname1 v_type1
      vname2 v_type2
  )
  ```

**一些小技巧**

- 并行 或 同时 赋值

  ```go
  a, b, c := 5, 7, "abc"
  ```

- 如果你想要交换两个变量的值，则可以简单地使用 **a, b = b, a**，两个变量的类型必须是相同。

- 空白标识符 _ 也被用于抛弃值，如值 5 在：_, b = 5, 7 中被抛弃。_

   实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。

### 值类型和引用类型

- 值类型

所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值：

![4.4.2_fig4.1](https://www.runoob.com/wp-content/uploads/2015/06/4.4.2_fig4.1.jpgrawtrue)

当使用等号 `=` 将一个变量的值赋值给另一个变量时，如：`j = i`，实际上是在内存中将 i 的值进行了拷贝：

![4.4.2_fig4.2](https://www.runoob.com/wp-content/uploads/2015/06/4.4.2_fig4.2.jpgrawtrue)

你可以通过 &i 来获取变量 i 的内存地址，例如：0xf840000040（每次的地址都可能不一样）。值类型的变量的值存储在栈中。

内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也可能不同。

更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。

- 引用类型

一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。

![4.4.2_fig4.3](https://www.runoob.com/wp-content/uploads/2015/06/4.4.2_fig4.3.jpgrawtrue)

这个内存地址称之为指针，这个指针实际上也被存在另外的某一个值中。

同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。

当使用赋值语句 r2 = r1 时，只有引用（地址）被复制。

如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响。

### 常量

#### 概念

常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。

#### 语法

- 常量的定义格式：

```go
const identifier [type] = value
```

- 多个相同类型的声明可以简写为：

```
const c_name1, c_name2 = value1, value2
```

- 常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过。

  ```go
  package main
  
  import "unsafe"
  const (
      a = "abc"
      b = len(a)
      c = unsafe.Sizeof(a)
  )
  
  func main(){
      println(a, b, c)
  }
  ```

#### iota

iota，特殊常量，可以认为是一个可以被编译器修改的常量。iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。

```go
package main

import "fmt"

func main() {
    const (
            a = iota   //0
            b          //1
            c          //2
            d = "ha"   //独立值，iota += 1
            e          //"ha"   iota += 1
            f = 100    //iota +=1
            g          //100  iota +=1
            h = iota   //7,恢复计数
            i          //8
    )
    fmt.Println(a,b,c,d,e,f,g,h,i)
}
//output 0 1 2 ha ha 100 100 7 8
```

```go
package main

import "fmt"
const (
    i=1<<iota
    j=3<<iota
    k
    l
)

func main() {
    fmt.Println("i=",i)
    fmt.Println("j=",j)
    fmt.Println("k=",k)
    fmt.Println("l=",l)
}
/*output
i= 1
j= 6
k= 12
l= 24
*/
```

## 运算符

- 算术运算符

  | 运算符 | 描述 | 实例               |
  | :----- | :--- | :----------------- |
  | +      | 相加 | A + B 输出结果 30  |
  | -      | 相减 | A - B 输出结果 -10 |
  | *      | 相乘 | A * B 输出结果 200 |
  | /      | 相除 | B / A 输出结果 2   |
  | %      | 求余 | B % A 输出结果 0   |
  | ++     | 自增 | A++ 输出结果 11    |
  | --     | 自减 | A-- 输出结果 9     |

- 关系运算符

  | 运算符 | 描述                                                         | 实例              |
  | :----- | :----------------------------------------------------------- | :---------------- |
  | ==     | 检查两个值是否相等，如果相等返回 True 否则返回 False。       | (A == B) 为 False |
  | !=     | 检查两个值是否不相等，如果不相等返回 True 否则返回 False。   | (A != B) 为 True  |
  | >      | 检查左边值是否大于右边值，如果是返回 True 否则返回 False。   | (A > B) 为 False  |
  | <      | 检查左边值是否小于右边值，如果是返回 True 否则返回 False。   | (A < B) 为 True   |
  | >=     | 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。 | (A >= B) 为 False |
  | <=     | 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。 | (A <= B) 为 True  |

- 逻辑运算符

  | 运算符 | 描述                                                         | 实例               |
  | :----- | :----------------------------------------------------------- | :----------------- |
  | &&     | 逻辑 AND 运算符。 如果两边的操作数都是 True，则条件 True，否则为 False。 | (A && B) 为 False  |
  | \|\|   | 逻辑 OR 运算符。 如果两边的操作数有一个 True，则条件 True，否则为 False。 | (A \|\| B) 为 True |
  | !      | 逻辑 NOT 运算符。 如果条件为 True，则逻辑 NOT 条件 False，否则为 True。 | !(A && B) 为 Tru   |

- 位运算符

  | 运算符 | 描述                                                         | 实例                                   |
  | :----- | :----------------------------------------------------------- | :------------------------------------- |
  | &      | 按位与运算符"&"是双目运算符。 其功能是参与运算的两数各对应的二进位相与。 | (A & B) 结果为 12, 二进制为 0000 1100  |
  | \|     | 按位或运算符"\|"是双目运算符。 其功能是参与运算的两数各对应的二进位相或 | (A \| B) 结果为 61, 二进制为 0011 1101 |
  | ^      | 按位异或运算符"^"是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 | (A ^ B) 结果为 49, 二进制为 0011 0001  |
  | <<     | 左移运算符"<<"是双目运算符。左移n位就是乘以2的n次方。 其功能把"<<"左边的运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，高位丢弃，低位补0。 | A << 2 结果为 240 ，二进制为 1111 0000 |
  | >>     | 右移运算符">>"是双目运算符。右移n位就是除以2的n次方。 其功能是把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数。 | A >> 2                                 |

- 赋值运算符

  | 运算符 | 描述                                           | 实例                                  |
  | :----- | :--------------------------------------------- | :------------------------------------ |
  | =      | 简单的赋值运算符，将一个表达式的值赋给一个左值 | C = A + B 将 A + B 表达式结果赋值给 C |
  | +=     | 相加后再赋值                                   | C += A 等于 C = C + A                 |
  | -=     | 相减后再赋值                                   | C -= A 等于 C = C - A                 |
  | *=     | 相乘后再赋值                                   | C *= A 等于 C = C * A                 |
  | /=     | 相除后再赋值                                   | C /= A 等于 C = C / A                 |
  | %=     | 求余后再赋值                                   | C %= A 等于 C = C % A                 |
  | <<=    | 左移后赋值                                     | C <<= 2 等于 C = C << 2               |
  | >>=    | 右移后赋值                                     | C >>= 2 等于 C = C >> 2               |
  | &=     | 按位与后赋值                                   | C &= 2 等于 C = C & 2                 |
  | ^=     | 按位异或后赋值                                 | C ^= 2 等于 C = C ^ 2                 |
  | \|=    | 按位或后赋值                                   | C \|= 2 等于 C = C \| 2               |

- 其他

  | 运算符 | 描述             | 实例                       |
  | :----- | :--------------- | :------------------------- |
  | &      | 返回变量存储地址 | &a; 将给出变量的实际地址。 |
  | *      | 指针变量。       | *a; 是一个指针变量         |

**运算符优先级**

| 优先级 | 运算符           |
| :----- | :--------------- |
| 5      | * / % << >> & &^ |
| 4      | + - \| ^         |
| 3      | == != < <= > >=  |
| 2      | &&               |
| 1      | \|\|             |

## 条件控制

| 语句                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [if 语句](https://www.runoob.com/go/go-if-statement.html)    | **if 语句** 由一个布尔表达式后紧跟一个或多个语句组成。       |
| [if...else 语句](https://www.runoob.com/go/go-if-else-statement.html) | **if 语句** 后可以使用可选的 **else 语句**, else 语句中的表达式在布尔表达式为 false 时执行。 |
| [if 嵌套语句](https://www.runoob.com/go/go-nested-if-statements.html) | 你可以在 **if** 或 **else if** 语句中嵌入一个或多个 **if** 或 **else if** 语句。 |
| [switch 语句](https://www.runoob.com/go/go-switch-statement.html) | **switch** 语句用于基于不同条件执行不同动作。                |
| [select 语句](https://www.runoob.com/go/go-select-statement.html) | **select** 语句类似于 **switch** 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。 |

| 循环类型                                                   | 描述                                 |
| :--------------------------------------------------------- | :----------------------------------- |
| [for 循环](https://www.runoob.com/go/go-for-loop.html)     | 重复执行语句块                       |
| [循环嵌套](https://www.runoob.com/go/go-nested-loops.html) | 在 for 循环中嵌套一个或多个 for 循环 |

注意：Go 语言中 range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对。

```go
// demo
package main
import "fmt"
func main() {
    //这是我们使用range去求一个slice的和。使用数组跟这个很类似
    nums := []int{2, 3, 4}
    sum := 0
    for _, num := range nums {
        sum += num
    }
    fmt.Println("sum:", sum)
    //在数组上使用range将传入index和值两个变量。上面那个例子我们不需要使用该元素的序号，所以我们使用空白符"_"省略了。有时侯我们确实需要知道它的索引。
    for i, num := range nums {
        if num == 3 {
            fmt.Println("index:", i)
        }
    }
    //range也可以用在map的键值对上。
    kvs := map[string]string{"a": "apple", "b": "banana"}
    for k, v := range kvs {
        fmt.Printf("%s -> %s\n", k, v)
    }
    //range也可以用来枚举Unicode字符串。第一个参数是字符的索引，第二个是字符（Unicode的值）本身。
    for i, c := range "go" {
        fmt.Println(i, c)
    }
}
```



| [break 语句](https://www.runoob.com/go/go-break-statement.html) | 经常用于中断当前 for 循环或跳出 switch 语句      |
| ------------------------------------------------------------ | ------------------------------------------------ |
| [continue 语句](https://www.runoob.com/go/go-continue-statement.html) | 跳过当前循环的剩余语句，然后继续进行下一轮循环。 |
| [goto 语句](https://www.runoob.com/go/go-goto-statement.html) | 将控制转移到被标记的语句。                       |

## 函数

### 函数定义

```go
func function_name( [parameter list] ) [return_types] {
   函数体
}
```

- 返回值可以有多个

  ```go
  package main
  
  import "fmt"
  
  func swap(x, y string) (string, string) {
     return y, x
  }
  
  func main() {
     a, b := swap("Google", "Runoob")
     fmt.Println(a, b)
  }
  ```

- Go 语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑。

### 传参方式

| 传递类型                                                     | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [值传递](https://www.runoob.com/go/go-function-call-by-value.html) | 值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。 |
| [引用传递](https://www.runoob.com/go/go-function-call-by-reference.html) | 引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。 |

### 函数用法

| 函数用法                                                     | 描述                                     |
| :----------------------------------------------------------- | :--------------------------------------- |
| [函数作为另外一个函数的实参](https://www.runoob.com/go/go-function-as-values.html) | 函数定义后可作为另外一个函数的实参数传入 |
| [闭包](https://www.runoob.com/go/go-function-closures.html)  | 闭包是匿名函数，可在动态编程中使用       |
| [方法](https://www.runoob.com/go/go-method.html)             | 方法就是一个包含了接受者的函数           |

# 数据结构

## 数组

### 语法结构

- 一维数组

```go
var variable_name [SIZE] variable_type
// example
var balance [10] float32
```

- 多维数组

```go
var variable_name [SIZE1][SIZE2]...[SIZEN] variable_type
// example;
var threedim [5][10][4]int
```

### 初始化

- 声明数组的同时快速初始化数组

  ```go
  balance := [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
  ```

- 数组长度不确定，可以使用 **...** 代替数组的长度

  ```go
  balance := [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
  ```

- 通过指定下标来初始化元素

  ```go
  //  将索引为 1 和 3 的元素初始化
  balance := [5]float32{1:2.0,3:7.0}
  ```

### 访问

```go
var salary float32 = balance[9]
```

### 数组传参

- 不设定数组大小

  ```go
  void myFunction(param []int)
  ```

- 设定数组大小

  ```go
  void myFunction(param [10]int)
  ```

## 指针

### 概念

一个指针变量指向了一个值的内存地址。

- 语法

```go
var var_name *var-type
```

```go
var ip *int        /* 指向整型*/
var fp *float32    /* 指向浮点型 */
```

```go
// demo
package main

import "fmt"

func main() {
   var a int= 20   /* 声明实际变量 */
   var ip *int        /* 声明指针变量 */

   ip = &a  /* 指针变量的存储地址 */

   fmt.Printf("a 变量的地址是: %x\n", &a  )

   /* 指针变量的存储地址 */
   fmt.Printf("ip 变量储存的指针地址: %x\n", ip )

   /* 使用指针访问值 */
   fmt.Printf("*ip 变量的值: %d\n", *ip )
}
```

### 空指针

当一个指针被定义后没有分配到任何变量时，它的值为 nil。

nil 指针也称为空指针。

nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。

## 结构体

数组可以存储同一类型的数据，但在结构体中我们可以为不同项定义不同的数据类型。

### 语法

- 定义

```go
type struct_variable_type struct {
   member definition
   member definition
   ...
   member definition
}
```

- 声明

```go
variable_name := structure_variable_type {value1, value2...valuen}
或
variable_name := structure_variable_type { key1: value1, key2: value2..., keyn: valuen}
```

```go
// demo
package main

import "fmt"

type Books struct {
   title string
   author string
   subject string
   book_id int
}


func main() {

    // 创建一个新的结构体
    fmt.Println(Books{"Go 语言", "www.runoob.com", "Go 语言教程", 6495407})

    // 也可以使用 key => value 格式
    fmt.Println(Books{title: "Go 语言", author: "www.runoob.com", subject: "Go 语言教程", book_id: 6495407})

    // 忽略的字段为 0 或 空
   fmt.Println(Books{title: "Go 语言", author: "www.runoob.com"})
```

- 访问结构体成员，需要使用点号 **.** 操作符

### 作为函数参数

- 结构体
- 结构体指针

## 切片（Slice）

Go 语言切片是对数组的抽象。

Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片("动态数组")，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。

### 创建

- 未指定大小的数组来定义切片

  ```go
  var identifier []type
  ```

- **make()** 函数来创建切片:

  ```go
  var slice1 []type = make([]type, len) //  len 是数组的长度并且也是切片的初始长度
  
  //也可以简写为
  
  slice1 := make([]type, len)
  ```

  也可以指定容量，其中 **capacity** 为可选参数。

  ```go
  make([]T, length, capacity)
  ```

### 初始化

- 直接初始化

  ```go
  s :=[] int {1,2,3 } 
  ```

- 通过数组/切片初始化

  ```go
  s := arr[:] 
  s := arr[startIndex:endIndex] 
  s1 := s[startIndex:endIndex] 
  ```

- make()函数初始化

  ```go
  s :=make([]int,len,cap) 
  ```

注意：个切片在未初始化之前默认为 nil，长度为 0

### 相关函数

- len() 获取长度

- cap() 测量切片最长可以达到多少

- append() 向切片追加新元素

  ```go
  numbers = append(numbers, 1)
  ```

- copy() 拷贝切片

  ```go
  /* 拷贝 numbers 的内容到 numbers1 */
     copy(numbers1,numbers)
  ```

## Map集合

Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。

Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。

### 定义

- map关键字

  ```go
  /* 声明变量，默认 map 是 nil */
  var map_variable map[key_data_type]value_data_type
  ```

- make

  ```go
  /* 使用 make 函数 */
  map_variable := make(map[key_data_type]value_data_type)
  ```

### 操作

- 插入

  ```go
  /* map插入key - value对,各个国家对应的首都 */
      countryCapitalMap [ "France" ] = "巴黎"
      countryCapitalMap [ "Italy" ] = "罗马"
      countryCapitalMap [ "Japan" ] = "东京"
      countryCapitalMap [ "India " ] = "新德里"
  ```

- 判断key是否存在

  ```go
   /*查看元素在集合中是否存在 */
      capital, ok := countryCapitalMap [ "American" ] /*如果确定是真实的,则存在,否则不存在 */
      /*fmt.Println(capital) */
      /*fmt.Println(ok) */
      if (ok) {
          fmt.Println("American 的首都是", capital)
      } else {
          fmt.Println("American 的首都不存在")
      }
  /* output 
  India  首都是 新德里
  American 的首都不存在
  */
  ```

- 遍历

  ```go
   /*使用键输出地图值 */ 
      for country := range countryCapitalMap {
          fmt.Println(country, "首都是", countryCapitalMap [country])
      }
  ```

- 删除元素

  ```go
  delete(countryCapitalMap, "France")
  ```

# 语言设计

## 接口

- 定义

  ```go
  /* 定义接口 */
  type interface_name interface {
     method_name1 [return_type]
     method_name2 [return_type]
     method_name3 [return_type]
     ...
     method_namen [return_type]
  }
  /* 定义结构体 */
  type struct_name struct {
     /* variables */
  }
  ```

- 实现

  ```go
  func (struct_name_variable struct_name) method_namen() [return_type] {
     /* 方法实现*/
  }
  ```

```go
// demo
package main

import (
    "fmt"
)

type Phone interface {
    call()
}

type NokiaPhone struct {
}

func (nokiaPhone NokiaPhone) call() {
    fmt.Println("I am Nokia, I can call you!")
}

type IPhone struct {
}

func (iPhone IPhone) call() {
    fmt.Println("I am iPhone, I can call you!")
}

func main() {
    var phone Phone

    phone = new(NokiaPhone)
    phone.call()

    phone = new(IPhone)
    phone.call()

}
```

- 注意make和new关键字（详细参考[Go语言 make和new关键字的区别](https://www.cnblogs.com/personblog/p/12261959.html))

  Go语言中 new 和 make 是两个内置函数，主要用来创建并分配类型的内存。在我们定义变量的时候，可能会觉得有点迷惑，不知道应该使用哪个函数来声明变量，其实他们的规则很简单，new 只分配内存，而 make 只能用于 slice、map 和 channel 的初始化。

  - new 函数只接受一个参数，这个参数是一个类型，并且**返回一个指向该类型内存地址的指针**。同时 new 函数会把分配的内存置为零，也就是类型的零值。　　　　
  - make 也是用于内存分配的，但是和 new 不同，它只用于 chan、map 以及 slice 的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。

## 错误处理

Go 语言通过内置的错误接口提供了非常简单的错误处理机制。

### 定义

```go
type error interface {
    Error() string
}
```

### 使用

- errors.New(...)

  ```go
  func Sqrt(f float64) (float64, error) {
      if f < 0 {
          return 0, errors.New("math: square root of negative number")
      }
      // 实现
  }
  ```

- 自定义实现Error()

  ```go
  package main
  
  import (
      "fmt"
  )
  
  // 定义一个 DivideError 结构
  type DivideError struct {
      dividee int
      divider int
  }
  
  // 实现 `error` 接口
  func (de *DivideError) Error() string {
      strFormat := `
      Cannot proceed, the divider is zero.
      dividee: %d
      divider: 0
  `
      return fmt.Sprintf(strFormat, de.dividee)
  }
  
  // 定义 `int` 类型除法运算的函数
  func Divide(varDividee int, varDivider int) (result int, errorMsg string) {
      if varDivider == 0 {
              dData := DivideError{
                      dividee: varDividee,
                      divider: varDivider,
              }
              errorMsg = dData.Error()
              return
      } else {
              return varDividee / varDivider, ""
      }
  
  }
  
  func main() {
  
      // 正常情况
      if result, errorMsg := Divide(100, 10); errorMsg == "" {
              fmt.Println("100/10 = ", result)
      }
      // 当除数为零的时候会返回错误信息
      if _, errorMsg := Divide(100, 0); errorMsg != "" {
              fmt.Println("errorMsg is: ", errorMsg)
      }
  
  }
  ```

## 并发

Go 允许使用 go 语句开启一个新的运行期线程， 即 goroutine，以一个不同的、新创建的 goroutine 来执行一个函数。 同一个程序中的所有 goroutine 共享同一个地址空间。

Go 语言支持并发，我们只需要通过 go 关键字来开启 goroutine 即可。

goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。

### goroutine语法

```go
go 函数名( 参数列表 )
```

### 线程通信

通道（channel）是用来传递数据的一个数据结构。

通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符 `<-` 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。

```go
ch <- v    // 把 v 发送到通道 ch
v := <-ch  // 从 ch 接收数据
           // 并把值赋给 v
```

#### 通道声明

- 声明通道 chan关键字

  ```go
  ch := make(chan int)
  ```

- 带缓冲区的通道

  ```go
  ch := make(chan int, 100)
  ```

#### 通信中的阻塞

带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。

不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。

**注意**：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。

#### 遍历通道

Go 通过 range 关键字来实现遍历读取到的数据，类似于与数组或切片

```go
package main

import (
        "fmt"
)

func fibonacci(n int, c chan int) {
        x, y := 0, 1
        for i := 0; i < n; i++ {
                c <- x
                x, y = y, x+y
        }
        close(c)
}

func main() {
        c := make(chan int, 10)
        go fibonacci(cap(c), c)
        // range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个
        // 数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据
        // 之后就结束了。如果上面的 c 通道不关闭，那么 range 函数就不
        // 会结束，从而在接收第 11 个数据的时候就阻塞了。
        for i := range c {
                fmt.Println(i)
        }
}
```

#### 通道关闭

接收数据时格式如下：

```go
v, ok := <-ch
```

如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 **close()** 函数来关闭

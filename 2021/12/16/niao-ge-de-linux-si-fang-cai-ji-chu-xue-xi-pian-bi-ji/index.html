<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="《鸟哥的LINUX私房菜_基础学习篇》笔记, 小小千千 Blog">
    <meta name="description" content="心怀梦想 不惧前行">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>《鸟哥的LINUX私房菜_基础学习篇》笔记 | 小小千千 Blog</title>
    <link rel="icon" type="image/png" href="/medias/logo-jiagou.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.1"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo-jiagou.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">小小千千 Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo-jiagou.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">小小千千 Blog</div>
        <div class="logo-desc">
            
            心怀梦想 不惧前行
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/Jason-QianHao" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/Jason-QianHao" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/47.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">《鸟哥的LINUX私房菜_基础学习篇》笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                <span class="chip bg-color">操作系统</span>
                            </a>
                        
                            <a href="/tags/Linux/">
                                <span class="chip bg-color">Linux</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-category">
                                操作系统
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-12-16
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    23k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    83 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="《鸟哥的LINUX私房菜-基础学习篇》笔记"><a href="#《鸟哥的LINUX私房菜-基础学习篇》笔记" class="headerlink" title="《鸟哥的LINUX私房菜_基础学习篇》笔记"></a>《鸟哥的LINUX私房菜_基础学习篇》笔记</h1><p>现在有<a target="_blank" rel="noopener" href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/1.html">在线阅读</a>版本了</p>
<h1 id="计算机概论"><a href="#计算机概论" class="headerlink" title="计算机概论"></a>计算机概论</h1><h2 id="计算机五大单元"><a href="#计算机五大单元" class="headerlink" title="计算机五大单元"></a>计算机五大单元</h2><p>主要分为三部分：<strong>输入单元、中央处理器(CPU)、输出单元</strong></p>
<p>五大单元：输入单元、输出单元、CPU内部的控制单元、算术逻辑单元、内存。</p>
<img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211216154107969.png" alt="image-20211216154107969" style="zoom:70%;" />

<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><h4 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h4><p>​    我们所使用的软件都要经过CPU内部的<strong>微指令集</strong>来完成才行。</p>
<p>​    指令集的设计分为两种设计理念，即两种主要的CPU种类：</p>
<ul>
<li>精简指令集RISC<ul>
<li>每个指令执行时间短，性能较佳，但要做复杂的事情需要多个指令完成。</li>
<li>常见CPU公司：Sun的SPARC系列，IBM的Power Architecture系列和<strong>ARM</strong>系列</li>
<li>常见于，学术大型工作站一般使用SPARC；品牌手机、导航系统、网络交换机、路由器等都是<strong>ARM，是目前世界上使用范围最广的CPU</strong></li>
</ul>
</li>
<li>复杂指令集CISC<ul>
<li>指令数目多而且复杂，花费时间长，但每个指令可以处理复杂的工作。</li>
<li>常见有AMD、Intel、VIA等x86架构等CPU。x86架构CPU被大量用于个人计算机。</li>
<li><strong>x86名字的由来，是因为最早的那个Intel发展的CPU代号8086，后面又有80286，80386等，所以这种架构的CPU就称为x86架构</strong>。2003年后，Intel的x86架构CPU由8位升级到16、32位，后来<strong>AMD依次架构修改为64位CPU</strong>，为了区别两者，64位的个人计算机CPU统称为X86_64架构。</li>
</ul>
</li>
</ul>
<h4 id="CPU频率"><a href="#CPU频率" class="headerlink" title="CPU频率"></a>CPU频率</h4><ul>
<li><p>概念</p>
<p>CPU每秒钟可以进行的工作次数。</p>
<blockquote>
<p> CPU频率位3.0GHz，表示CPU在一秒内可以进行3.0*10^9次工作，<strong>每次工作可以进行少数的指令运行</strong>。</p>
</blockquote>
</li>
<li><p>外频与倍频</p>
<p>CPU与外部各组件速度不一致，很多数据都在CPU内处理，故开发商在CPU内再加上一个加速功能。</p>
<ul>
<li>外频，CPU与外部组件进行数据传输/运算的速度</li>
<li>倍频，CPU内部用来加速工作性能的一个倍数</li>
</ul>
<p>两者相乘才是CPU频率。</p>
<blockquote>
<p>上面例子CPU频率3.0GHz，而外频是333MHz，那么倍频就是9倍。</p>
</blockquote>
</li>
</ul>
<h4 id="32位与64位"><a href="#32位与64位" class="headerlink" title="32位与64位"></a>32位与64位</h4><p>​    总线宽度可以分为32/64bit。总线速度 = 总线传输速度(频率) * 总线宽度。</p>
<p>​    CPU每次能够处理的数据量称为<strong>字组大小</strong>，依据CPU的设计而有32位和64位。<strong>现在所称的计算机是32位或是64位主要是依据CPU解析字组大小而来</strong>。CPU每次能解析的数据量有限，因此内存传来的数据量就有所限制。</p>
<p>​    <strong>字组大小和总线宽度可以不同</strong>。</p>
<h4 id="CPU等级"><a href="#CPU等级" class="headerlink" title="CPU等级"></a>CPU等级</h4><p>​    1993年左右，x86架构的CPU在intel的Pentium系列后设计不统一，出现i386、i586、i686等名词出现。</p>
<ul>
<li>在Intel Pentium MMX与AMD K6年代的CPU统称为i586等级</li>
<li>Intel Celeron与AMD Athlon(K7)年代之后的32位CPU称为i686等级</li>
<li>目前64位CPU则统称为x86_64等级。</li>
</ul>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>​    不论是软件程序还是数据，都必须要读如内存后CPU才能使用。</p>
<h4 id="内存组件"><a href="#内存组件" class="headerlink" title="内存组件"></a>内存组件</h4><p>​    个人PC中主要位动态随机访问内存（DRAM）。断电后数据消失，也称为<strong>挥发性内存</strong>。</p>
<p>​    通常内存越大表示系统越快，因为系统不用常常释放一些内存内部的数据。<strong>对服务器而言，内存的容量有时比CPU的速度还重要</strong>。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211216164842031.png" alt="image-20211216164842031"></p>
<p>​    <strong>理论上，CPU与内存的外频应该要相同才好</strong>。</p>
<h4 id="双通道设计"><a href="#双通道设计" class="headerlink" title="双通道设计"></a>双通道设计</h4><p>​    传统总线宽度仅为64位，为了加大这个宽度，可以将两个内存汇整在一起，则可以达到128位。数据可以同步写入/读出内存中，提升整体的频宽。</p>
<p>​    开启双通道的内存，容量和型号最好相同！</p>
<h4 id="第二缓存"><a href="#第二缓存" class="headerlink" title="第二缓存"></a>第二缓存</h4><p>​    为了某些常用的程序或者数据可以放置到CPU内部而设计，那么CPU数据的读取就不需要通过北桥了。</p>
<img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211216165422900.png" alt="image-20211216165422900" style="zoom:50%;" />

<p>​    第二缓存(L2 Cache)在CPU内部，故L2内存的速度必须要与CPU频率相同。DRAM无法到达，故使用SRAM。</p>
<h2 id="常用计算单位"><a href="#常用计算单位" class="headerlink" title="常用计算单位"></a>常用计算单位</h2><ul>
<li><p>大小单位</p>
<p>1Byte = 8bit</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211216160717997.png" alt="image-20211216160717997"></p>
</li>
<li><p>速度单位</p>
<ul>
<li>CPU的运算速度常使用MHz或GHz</li>
<li>网络常使用Mbit/s，即每秒多少Mbit</li>
</ul>
</li>
</ul>
<h2 id="接口设备"><a href="#接口设备" class="headerlink" title="接口设备"></a>接口设备</h2><p>​    单有CPU也无法运作计算机，需要其他的接口设备才能实际运行。</p>
<h3 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h3><h4 id="主板芯片组"><a href="#主板芯片组" class="headerlink" title="主板芯片组"></a>主板芯片组</h4><ul>
<li>负责将所有的设备连接在一起，让所有的设备能够进行协调与通信。主板上最重要的组件是主板<strong>芯片组</strong>。</li>
<li>芯片组通常分为两个桥接器来控制各组件的通信<ul>
<li>北桥负责连接速度较快的CPU、内存与显卡等组件。<strong>北桥的总线称为系统总线</strong>，因为是内存传输的主要信道。</li>
<li>南桥负责连接速度较慢的周边接口，包括硬盘、USB、网卡等，**南桥的总线是输入输出总线(IO)**。</li>
</ul>
</li>
<li>芯片组负责所有通信，所以也是一个可能会散发出高热量的组件。因此主板上面会发现一些外接的小风扇或者是散热片。</li>
</ul>
<h4 id="IO地址与IRQ中断信道"><a href="#IO地址与IRQ中断信道" class="headerlink" title="IO地址与IRQ中断信道"></a>IO地址与IRQ中断信道</h4><p>​    是主板芯片组和其他设备通信的具体通信方式。</p>
<ul>
<li>每个设备都有自己的IO地址。一般不能有两个设备使用同一个IO地址（类比<strong>门牌号</strong>）</li>
<li>各设备可以通过IRQ中断通信信道来告知CPU该设备的工作情况，以方便CPU进行工作分配的任务。（类比**各个门牌连接到邮件中心CPU的专门路径。</li>
</ul>
<h4 id="CMOS与BIOS"><a href="#CMOS与BIOS" class="headerlink" title="CMOS与BIOS"></a>CMOS与BIOS</h4><ul>
<li>CMOS主要<strong>记录主板上面的重要参数</strong>，包括系统时间、CPU电压与频率、各项设备IO地址与IRQ等。<strong>由于记录这些数据需要花费店里，故主板上面才有电池</strong>。</li>
<li>BIOS位写入到主板闪存或EEPROM的程序，他可以<strong>在开机的时候执行</strong>，以加载CMOS当中的参数，并尝试调用存储设备中的开机程序，进行一步进入操作系统。</li>
</ul>
<h3 id="存储设备"><a href="#存储设备" class="headerlink" title="存储设备"></a>存储设备</h3><p>​    存储设备包括：硬盘、软盘、MO、CD、DVD、U盘等。其中最常见的是<strong>硬盘</strong>。</p>
<h4 id="硬盘的物理组成"><a href="#硬盘的物理组成" class="headerlink" title="硬盘的物理组成"></a>硬盘的物理组成</h4><p>​    主要由很多的盘片、机械手臂、磁头与主轴马达组成。实际的数据写在具有磁性物质的盘片上。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211217173130463.png" alt="image-20211217173130463"></p>
<h4 id="盘片的数据"><a href="#盘片的数据" class="headerlink" title="盘片的数据"></a>盘片的数据</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211217173212439.png" alt="image-20211217173212439"></p>
<ul>
<li><p>扇区：由同心圆以放射状的方式分割出磁盘的<strong>最小存储单位</strong>，每个扇区大小<strong>512bytes</strong>，<strong>这个值是固定的</strong>。</p>
</li>
<li><p>磁道：扇区组成的一个就是磁道。</p>
</li>
<li><p>柱面：在多磁盘上面，同一个磁道可以组成一个柱面，<strong>也是一般分割磁盘时的最小单位</strong>。</p>
</li>
</ul>
<h4 id="传输接口"><a href="#传输接口" class="headerlink" title="传输接口"></a>传输接口</h4><ul>
<li><p>IDE接口</p>
</li>
<li><p>SATA接口</p>
<p>排线较细小，有利于主机壳内部的散热与安装。</p>
<p>目前主流的个人计算机硬盘已经被SATA代替了。SATA-2传输速度可达300MB/s。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211217174256889.png" alt="image-20211217174256889"></p>
</li>
<li><p>SCSI接口</p>
<p>用于工作站等级以上的硬盘传输接口。硬盘的控制器含有一块处理器。</p>
</li>
</ul>
<h4 id="一些参数"><a href="#一些参数" class="headerlink" title="一些参数"></a>一些参数</h4><ul>
<li><p>容量</p>
</li>
<li><p>缓冲存储器</p>
<p>硬盘还有一个缓冲存储器，将硬盘内常用的数据缓存起来。这个缓冲器越大越好。</p>
</li>
<li><p>转速</p>
<p>指主轴马达转动盘片的速度，影响读取数据性能。越高越好。</p>
</li>
</ul>
<h3 id="显示设备"><a href="#显示设备" class="headerlink" title="显示设备"></a>显示设备</h3><ul>
<li><p>概念</p>
<p>显卡又称VGA(Video Graphics Array)。每个图像显示的颜色都会占用内存，所以显卡上面有一个内存容量，它将影响到最终屏幕分辨率和色彩深度。</p>
</li>
<li><p>GPU</p>
<p>显卡厂商为了缓解CPU进行3D运算压力，直接在显卡上面嵌入一个3D加速的芯片，即GPU由来。</p>
</li>
<li><p>与CPU通信</p>
<p>通过北桥芯片与CPU、内存通信。</p>
<p>也是需要告诉运算的组件，所以数据的传输速度越快越好。显卡规格变化：PCI —》AGP —》PCI-Express(PCIe)。他们主要区别在数据传输的频宽。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211217172647532.png" alt="image-20211217172647532"></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211217172702238.png" alt="image-20211217172702238"></p>
</li>
</ul>
<h3 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h3><h3 id="其他设备"><a href="#其他设备" class="headerlink" title="其他设备"></a>其他设备</h3><h4 id="PCI-e-适配卡"><a href="#PCI-e-适配卡" class="headerlink" title="PCI(e)适配卡"></a>PCI(e)适配卡</h4><p>​    提供多个PCI(e)插槽给用户插入其他功能卡。</p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>​    提供一个开发软件的操作接口给工程师开发软件，通过接口即可驱动所有的硬件。</p>
<p>​    <strong>操作系统其实也是一组程序</strong>，这组程序的重点在于管理计算机的所有活动以及驱动系统中的所有硬件。</p>
<h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><p>​    让CPU开始判断逻辑与运算数值，让内存开始读取数据与程序代码，让硬盘开始被访问等。硬件的所有操作都必须通过操作系统完成。<strong>这就是操作系统内核的功能</strong>。</p>
<p>​    主要在于管控硬件与提供相关的能力，非常重要，因此<strong>内核程序所放置到内存当中的区块是受保护的，并且开机后就一直常驻内存</strong>。</p>
<p><strong>内核通常包含一些功能</strong>：</p>
<ul>
<li>提供系统调用接口</li>
<li>程序管理：CPU调度机制有较加快整体系统性能</li>
<li>内存管理</li>
<li>文件系统管理</li>
<li>设备驱动</li>
</ul>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>​    <img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211218164627436.png" alt="image-20211218164627436" style="zoom:50%;" /></p>
<p>​    为了保护内核，并且而让程序员比较容易开发软件，因此操作系统除了内核程序之外，通常还会提供一整组开发接口，那就是<strong>系统调用</strong>。</p>
<h3 id="驱动程序"><a href="#驱动程序" class="headerlink" title="驱动程序"></a>驱动程序</h3><p>​    操作系统提供一个开发接口给硬件开发商，让他们可以根据这个接口设计可以驱动他们硬件的驱动程序，安装后就可以在操作系统上驱动硬件设备。</p>
<img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211218170823839.png" alt="image-20211218170823839" style="zoom:50%;" />

<h1 id="Linux概览"><a href="#Linux概览" class="headerlink" title="Linux概览"></a>Linux概览</h1><p>​    提供了一个完整的操作系统当中最底层的硬件控制与资源管理的完整架构，是沿袭Unix良好的传统而来的（UNIX Like 系统），所以<strong>相当稳定并且功能强大，且可以在目前的个人计算机（x86系统）上面跑。</strong></p>
<h2 id="一些历史"><a href="#一些历史" class="headerlink" title="一些历史"></a>一些历史</h2><ul>
<li><p>UNIX</p>
<ul>
<li>1973年，UNIX正式诞生，Ritchie等人以C语言写出第一个正式UNIX内核。</li>
<li>1977年，UNIX的重要分支<strong>BSD（Berkeley Software Distribution, Bill Joy也是Sun的创办者)诞生</strong>。</li>
<li>1984年，x86架构的Minix操作系统诞生。</li>
<li>1984年，Richard Mathew Stallman（史托曼）创建了<strong>GNU项目，目的是创建一个自由、开放的UNIX操作系统（Free UNIX)<strong>。1999年左右，创立</strong>自由软件基金会（Free Software Foundation, FSF)<strong>。1985年左右，为了避免GNU所开发的自由软件被其他人所利用而成为专利软件，与律师草拟了</strong>通用公共许可证（General Public License, GPL）</strong>，称为<strong>CopyLeft（与专利软件的CopyRight相对）</strong>。</li>
<li>1988年，由MIT（麻省理工学院）成立了非营利性性质的<strong>XFree86（X Windows System + Free + x86）</strong>。后面在Linux的GUI发展中有贡献。</li>
</ul>
</li>
<li><p>Linux</p>
<ul>
<li><p>1991年，芬兰大学生Linus Torvalds，以bash，gcc(GNU C Complie, 一种c语言编译器)等工具写了一个小小的内核程序，且可以在386机器上面运行。</p>
</li>
<li><p>期间，为了使LInux程序软件可以兼容UNIX，所以开始<strong>参考POSIX规范修改Linux</strong>。POSIX是可携式操作系统接口（Portable Operating System Interface)缩写，重点在于规范内核与应用程序之间的接口，由IEEE发布的一项标准。UNIX即按照这个规范来设计的。</p>
</li>
<li><p>1994年，在广大网友合作下完成Linux的内核正式版Version 1.0。这一版本还有X Window System的支持。1996年完成2.0版本。</p>
</li>
<li><p>为了让用户能够接触到Linux，很多的商业公司和团体奖Linux Kernel(含tools)与可运行的软件集成起来，放到光盘或网络给用户安装。这个<strong>”Kernel + softwares + Tools”的可完全安装的系统，称为Linux distribution可完全安装套件</strong>。</p>
<p>distributions主要分为两大系统：</p>
<ul>
<li><p>使用RPM安装软件的系统，如Red Hat, Fedora, SuSE等。</p>
</li>
<li><p>使用Debian等dpkg方式安装软件等系统，如Debian, Ubuntu, B2D等。</p>
<h2 id="Linux特色"><a href="#Linux特色" class="headerlink" title="Linux特色"></a>Linux特色</h2></li>
</ul>
</li>
</ul>
</li>
<li><p>配置需求低廉</p>
</li>
<li><p>系统稳定</p>
</li>
<li><p>保密功能强</p>
</li>
<li><p>架构开放，开源，免费或少许费用</p>
</li>
<li><p>多任务、多用户</p>
</li>
</ul>
<h2 id="Linux文件"><a href="#Linux文件" class="headerlink" title="Linux文件"></a>Linux文件</h2><p>​    <strong>在Linux系统中，每个设备都被当成一个文件来对待</strong>。常见设备与对应Linux文件名如下：</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211220105319380.png" alt="image-20211220105319380"></p>
<p>​    几乎所有的硬件设备文件都在<code>/dev</code>这个目录内。</p>
<p>​    系统通过文件的<strong>major与minor</strong>数值识别设备文件。常见硬盘的值如下：</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211229145645115.png" alt="image-20211229145645115"></p>
<h2 id="Linux文件结构和磁盘挂载"><a href="#Linux文件结构和磁盘挂载" class="headerlink" title="Linux文件结构和磁盘挂载"></a>Linux文件结构和磁盘挂载</h2><ul>
<li>文件结构</li>
</ul>
<p>​    Linux使用<strong>目录树</strong>结构，以根目录（/）为主，然后向下呈现分枝状的目录结构的一种文件结构。</p>
<p>​    如何结合目录树的架构与磁盘内的数据，这个时候就牵扯到“挂载”（mount）问题。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211222142446218.png" alt="image-20211222142446218"></p>
<ul>
<li><p>磁盘挂载</p>
<p>利用一个目录当进入点，将磁盘分区的数据放置在该目录下，即<strong>进入该目录就可以读取该分区</strong>。这个操作成为<strong>挂载</strong>，进入点的目录成为<strong>挂载点</strong>。</p>
<p>如下图，当数据放置在/home内的各个目录时，数据放置在partition2分区；当数据放置在其他目录时，数据放置在partiton1目录。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211222142819962.png" alt="image-20211222142819962"></p>
<h2 id="Linux磁盘分区"><a href="#Linux磁盘分区" class="headerlink" title="Linux磁盘分区"></a>Linux磁盘分区</h2><h3 id="磁盘分区文件"><a href="#磁盘分区文件" class="headerlink" title="磁盘分区文件"></a>磁盘分区文件</h3><p>​    <strong>整块磁盘的第一个扇区特别重要</strong>，记录了整块磁盘的重要信息。主要有两个重要的信息：</p>
<ul>
<li>主引导分区（Master Boot Record， MBR）：可以安装引导加载程序的地方，有446bytes。</li>
<li>分区表（partition table）：记录整块磁盘分区的状态，有64bytes。</li>
</ul>
<h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><p>​    分区的最小单位为<strong>柱面</strong>。分区是以<strong>柱面号码</strong>的方式记录，在分区表的64bytes中，总共分为<strong>四组记录区</strong>，每组及录取记录该区段的<strong>起始与结束的柱面号码</strong>。</p>
<p>​    分区表64bytes最多容纳四个分区，这四个分区被称为<strong>主(Primary)分区</strong>，若主分区被继续划分，则成为<strong>扩展(Extended)分区</strong>。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211220110119164.png" alt="image-20211220110119164"></p>
<p>​    假设硬盘为/dev/hda，则四个区的文件名为如下，其中后面跟的数字，与该分区所在的位置有关。</p>
<ul>
<li>P1: /dev/hda1</li>
<li>P2: /dev/hda2</li>
<li>P3: /dev/hda3</li>
<li>P4: /dev/hda4</li>
</ul>
<h3 id="扩展分区"><a href="#扩展分区" class="headerlink" title="扩展分区"></a>扩展分区</h3><p>​    Linux一块硬盘想分出不止四个分区，是可以的。<strong>既然第一个分区所在的分区表只能记录四条数据，那可以利用额外的扇区来记录更多的分区信息</strong>。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211220111330670.png" alt="image-20211220111330670"></p>
<p>​    上图P1称为主分区，P2称为扩展分区，L[1-5]由P2继续切分而来称为<strong>逻辑分区(logical partition)<strong>。设备文件名如下。注意没有/dev/hda3和/dev/hda4。因为</strong>前四个号码都是留给Primary或者Extended用的</strong></p>
<ul>
<li>P1: /dev/hda1</li>
<li>P2: /dev/hda2</li>
<li>L1: /dev/hda5</li>
<li>L2: /dev/hda6</li>
<li>L3: /dev/hda7</li>
<li>L4: /dev/hda8</li>
<li>L5: /dev/hda9</li>
</ul>
<p>​    有几个注意点：</p>
<ul>
<li>扩展分区最多只能有一个</li>
<li>能够被格式化后作为数据访问的分区为主分区和逻辑分区，扩展分区无法格式化</li>
<li>逻辑分区数量依操作系统不同，在Linux系统中，IDE硬盘最多59个逻辑分区（5-63号），SATA硬盘有11个逻辑分区（5号到15号）。</li>
</ul>
<h3 id="建议的磁盘规划"><a href="#建议的磁盘规划" class="headerlink" title="建议的磁盘规划"></a>建议的磁盘规划</h3><ul>
<li><p>简单的分区方法</p>
<p>仅分出根目录与内存交换空间(/ 和 swap)。</p>
<p>swap内存交换空间的功能是：当有数据被存放在物理内存里面，但是这些数据又不是常被CPU所取用时，那么这些不常被使用的程序将会被丢到硬盘的swap交换空间中，而将快速的物理内存空间释放出来给真正需要的程序使用。</p>
</li>
<li><p>稍微麻烦</p>
<p>需要较大容量和读写频繁的目录，独立于根目录分区。常见容量大或读写频繁的目录：</p>
<ul>
<li>/</li>
<li>/usr</li>
<li>/home</li>
<li>/var</li>
<li>swap</li>
</ul>
</li>
</ul>
<h2 id="Linux开机流程"><a href="#Linux开机流程" class="headerlink" title="Linux开机流程"></a>Linux开机流程</h2><h3 id="正常开机"><a href="#正常开机" class="headerlink" title="正常开机"></a>正常开机</h3><ol>
<li>BIOS，开机主动执行的程序，会识别第一个可开机的设备（硬盘）。</li>
<li>MBR，第一个可开机设备的第一个扇区内的主引导分区块，内包含引导加载程序。</li>
<li>引导加载程序（Boot loader），读取内核文件<ul>
<li>提供菜单：用户选择不同的开机选项，也是<strong>多重引导</strong>的重要功能。</li>
<li>载入内核文件：直接指向可开机的程序区段来开始操作系统</li>
<li>转交其他loader：将引导加载功能转交给其他loader负责。</li>
</ul>
</li>
<li>内核文件，内核文件工作，开始操作系统的功能。<ul>
<li>内核开始检测硬件与加载驱动程序</li>
<li>内核主动调用init进程，init进程取得run-level信息</li>
<li>init执行<code>/etc/rc.d/rc.sysinit</code>文件来准备软件执行的操作环境</li>
<li>init执行run-level的各个服务的启动</li>
<li>inti执行<code>/etc/rc.d/rc.local</code>文件</li>
<li>init执行终端机模拟程序<code>mingetty</code>来启动login进程，等待用户登录</li>
</ul>
</li>
</ol>
<h4 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h4><p>​    系统加载BIOS（Basic Input Output System）程序，来加载CMOS的信息，从而获得主机的各项<strong>硬件配置</strong>。包括：</p>
<ul>
<li>CPU与接口设备的通信频率</li>
<li>启动设备的查找顺序</li>
<li>硬盘的大小与类型</li>
<li>系统时间</li>
<li>总线信息</li>
<li>接口设备的IO地址</li>
<li>IRQ信息等等</li>
</ul>
<p>之后，BIOS继续进行<strong>开机自检、硬件检测的初始化、配置PnP（即插即用设备）、定义出可启动的设备顺序</strong>。后面就准备通过MBR开始读取启动设备的数据了。</p>
<h4 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h4><p>​    在启动设备的第一扇区，里面包含<strong>可以处理内核文件加载问题的引导装载程序，Boot Loader</strong>。</p>
<p>​    BIOS是通过硬件的INT13中断功能读取MBR。</p>
<h4 id="Boot-Loader"><a href="#Boot-Loader" class="headerlink" title="Boot Loader"></a>Boot Loader</h4><p>​    每种操作系统都有自己的Boot Loader，在自己磁盘分区的引导扇区(boot sector)。在安装Winodows的时候，会默认将windows在引导扇区的boot loader拷贝一份并安装到系统的MBR；在安装Linux的时候，可以选择装，也可以不装。</p>
<p>​    通过boot Loader提供的<strong>菜单功能</strong>，选择<strong>内核文件进行加载</strong>，同时可以配合<strong>loader的控制权转交的功能实现多重引导</strong>。但是，Windows的loader默认不具有控制权转交的功能。<strong>所以，在多系统的时候，一定要先装Windows再装Linux</strong>。</p>
<p>​    在具体boot loader执行过程中分为两个阶段：</p>
<ul>
<li><p>执行boot loader主程序</p>
<p>MBR通常仅安装了boot loader的最小主程序，并没有安装loader的相关配置文件</p>
</li>
<li><p>主程序加载配置文件</p>
<p>通过boot loader加载所有配置文件（一般在/boot下面）与相关的环境参数文件（文件系统定义与主要配置文件menu.lst）</p>
</li>
</ul>
<p><strong>现在常见的boot loader一般是grub</strong>，与grub有关的文件都放置到<code>/boot/grub</code>中。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220111144346433.png" alt="image-20220111144346433"></p>
<p>其中最重要的配置文件是<code>menu.lst</code>文件。</p>
<h4 id="加载内核检测硬件"><a href="#加载内核检测硬件" class="headerlink" title="加载内核检测硬件"></a>加载内核检测硬件</h4><p>​    Linux会将内核解压缩到内存中，并利用内核的功能，开始测试与驱动各个周边设备（存储设备、CPU、网卡、声卡等）。然后，内核<strong>重新检测一次硬件（不一定使用BIOS的硬件检测信息）</strong>，此时，<strong>内核正式开始接管BIOS的工作。</strong></p>
<p>​    内核文件被加载后，一般放置在<code>/boot</code>目录下。在<code>/boot/modules</code>内，有很多<strong>内核模块</strong>（可以想想成驱动程序，如USB、SATA等）可以供Linux内核动态加载，该目录一定和根目录放置在同一分区！启动过程中<strong>内核必须挂载根目录（此时，以只读方式挂载），这样才能内核模块提供加载驱动程序的功能</strong>。</p>
<blockquote>
<p>若Linux安装在SATA里面，会出现这样的矛盾：</p>
<p>​    内核不认识SATA接口，需要加载SATA程序，不然没办法挂载根目录；</p>
<p>​    但是SATA驱动程序在<code>/boot/modules</code>里面，不挂载根目录，无法读取这个目录的驱动程序。</p>
<p>这里，还有个<strong>虚拟文件系统（InitialRAM Disk，一般文件名为<code>/boot/initrd</code>）</strong>可以解决这个问题。它通过boot loader加载到内存解压缩后，在内存中仿真成一个根目录，来加载启动过程中需要的内核模块。等模块都载入完成后，帮助内核重新调用<code>/sbin/init</code>来继续启动流程。</p>
<p><strong>如果是ext2/ext3文件系统的IDE接口的磁盘，则不需要<code>initrd</code>就可以直接被内核加载。</strong></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220111133612615.png" alt="image-20220111133612615"></p>
<h4 id="init进程"><a href="#init进程" class="headerlink" title="init进程"></a>init进程</h4><p>​    内核加载完成、硬件检测完成和驱动程序加载后，内核主动调用第一个进程<code>/sbin/init</code>。主要的功能是准备软件执行的环境，包括：<strong>系统的主机名、网络设置、语系处理、文件系统格式及其它服务的启动</strong>。<code>init</code>进程的配置文件为**<code>/etc/inittab</code>**。</p>
<ul>
<li><p>重要的配置项<code>run level</code></p>
<p>根据有无网络与有无X Window划分为7个等级，来规定系统使用不同的服务来启动。</p>
<ul>
<li>0：halt，系统直接关机</li>
<li>1：single user mode，单用户维护模式，用在系统出问题时的维护</li>
<li>2：Multi user without NFS，多用户模式，但无NFS服务</li>
<li>3：Full multi user mode，完整含有网络功能的纯文本模式</li>
<li>4：unused，系统保留功能</li>
<li>5：X11，与run level3类型，但使用X Window模式加载</li>
<li>6：reboot，重新启动</li>
</ul>
</li>
<li><p><code>/etc/inittab</code>文件结构</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220111134232187.png" alt="image-20220111134232187"></p>
<p>配置语法：</p>
<p><code>[设置选项]:[run level]:[init的操作行为]:[命令选项]</code></p>
<ol>
<li><p>设置选项。最多四个字符，代表init的工作选项</p>
</li>
<li><p>run level，可能会配置多个等级</p>
</li>
<li><p>init的操作行为，主要如下：</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220111134943106.png" alt="image-20220111134943106"></p>
</li>
<li><p>选项命令，即可以进行的一些script命令</p>
</li>
</ol>
</li>
<li><p>init的处理流程</p>
<p>配置文件也是从上至下一行一行读取。</p>
<ul>
<li>取得默认run level</li>
<li>使用<code>/etc/rc.d/rc.sysinit</code>进行系统初始化，它里面的脚本主要配置文件是<code>/etc/sysconfig/*</code></li>
<li>如果此时run level是5，则加载<code>/etc/rc.d/rc5</code></li>
<li>设置好<code>[Ctrl]+[Alt]+[Del]</code>组合键</li>
<li>设置不断电系统的pf，pr两种机制</li>
<li>启动mingetty的6个终端机tty1~tty6</li>
<li>最终以<code>/etc/X11/perfdm -nodaemon启动图像界面</code></li>
</ul>
</li>
</ul>
<h4 id="etc-rc-d-rc-sysinit进行系统初始化"><a href="#etc-rc-d-rc-sysinit进行系统初始化" class="headerlink" title="/etc/rc.d/rc.sysinit进行系统初始化"></a><code>/etc/rc.d/rc.sysinit</code>进行系统初始化</h4><p>主要是设置各种系统环境，有以下：</p>
<ul>
<li><p>取得网络环境与主机类型</p>
<p>读取网络配置文件<code>/etc/sysconfig/network</code>，取得主机名与默认网关等网络环境</p>
</li>
<li><p>测试与挂载内存设备<code>/proc</code>及USB设备<code>/sys</code></p>
</li>
<li><p>决定是否启动SELinux</p>
</li>
<li><p>启动系统的随机数生成器</p>
</li>
<li><p>设置终端机字体</p>
</li>
<li><p>设置显示于启动过程找那个的欢迎界面</p>
</li>
<li><p>设置系统时间与时区</p>
<p>读取<code>/etc/sysconfig/clock</code>的设置值</p>
</li>
<li><p>接口设备的检测与PnP参数测试</p>
<p>根据内核在启动时的检测结果<code>/proc/sys/kernel/modprobe</code>来进行检测</p>
</li>
<li><p>用户自定义模块的加载</p>
<p>读取<code>/etc/sysconfig/modules/*.moduels</code></p>
</li>
<li><p>加载内核的相关设置</p>
<p>读取<code>/etc/ssyctl.conf</code></p>
</li>
<li><p>设置主机名与初始化电源管理模块</p>
</li>
<li><p>初始化软件磁盘阵列</p>
<p>读取<code>/etc/mdadm.conf</code></p>
</li>
<li><p>初始化LVM的文件系统</p>
</li>
<li><p>以fsck检验磁盘文件系统</p>
</li>
<li><p>进行磁盘配额quota的转化</p>
</li>
<li><p>重新以可读写模式挂载系统磁盘</p>
</li>
<li><p>启动quota</p>
</li>
<li><p>启动系统伪随机数生成器</p>
</li>
<li><p>清除启动过程中的临时文件</p>
</li>
<li><p>启动相关信息加载到<code>/var/log/dmesg</code>文件中</p>
</li>
</ul>
<h4 id="etc-rc-d-rcN启动系统服务"><a href="#etc-rc-d-rcN启动系统服务" class="headerlink" title="/etc/rc.d/rcN启动系统服务"></a>/etc/rc.d/rcN启动系统服务</h4><p>​    内部定义了启动时需要启动的服务信息，并有一定的启动先后顺序。</p>
<p>​    特别是最后一行，加载<code>/etc/rc.d/rc.local</code>文件，是用户自定义的开机启动程序</p>
<h3 id="多重引导"><a href="#多重引导" class="headerlink" title="多重引导"></a>多重引导</h3><p>其中引导加载程序除了可以安装在MBR之外，还可以安装在每个分区的引导扇区(boot sector)，才有了<strong>多重引导</strong>功能。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211220134716538.png" alt="image-20211220134716538"></p>
<p>​    每个分区都有自己的启动扇区，实际可开机的内核文件是放置在各分区内的。</p>
<p>​    loader只会认识自己的系统分区内的可开机内核文件和其他loader，loader可以直接指向或是间接将管理权转交另一个管理程序。</p>
<h2 id="Linux登录方式"><a href="#Linux登录方式" class="headerlink" title="Linux登录方式"></a>Linux登录方式</h2><p>​    在Linux默认登录模式中，主要分为两种：</p>
<ul>
<li>纯文本界面（运行等级 run level 3)，可以拥有tty1~tty6的终端界面。</li>
<li>图形界面（运行等级 run level 5），拥有tty1~tty7。其中tty7就是开机后等待登录的图形环境。</li>
</ul>
<p>登录环境的切换：</p>
<ul>
<li>[Ctrl] + [Alt] + [F1] ~ [F6]：文字界面登录tty1~tty6终端</li>
<li>[Ctrl] + [Alt] + [F7]：图形界面桌面</li>
</ul>
<h2 id="Linux内核"><a href="#Linux内核" class="headerlink" title="Linux内核"></a>Linux内核</h2><p>​    内核文件是个压缩文件，解压缩后才加载到内存中。内核文件相关位置：</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220111142448466.png" alt="image-20220111142448466"></p>
<h2 id="Linux命令行和简单命令"><a href="#Linux命令行和简单命令" class="headerlink" title="Linux命令行和简单命令"></a>Linux命令行和简单命令</h2><h3 id="可以输入多条命令"><a href="#可以输入多条命令" class="headerlink" title="可以输入多条命令"></a>可以输入多条命令</h3><p>​    使用**分号(;)**隔开多条命令，命令按顺序执行。</p>
<h3 id="可以换行输入命令"><a href="#可以换行输入命令" class="headerlink" title="可以换行输入命令"></a>可以换行输入命令</h3><p>​    当输入命令太长是时，可以使用<code>\[Enter]</code>进行换行输入</p>
<h3 id="用户符号区别"><a href="#用户符号区别" class="headerlink" title="用户符号区别"></a>用户符号区别</h3><ul>
<li><p>普通用户</p>
<p>[xxx@xxx <del>]$，其中`</del>`代表的是用户的主文件夹，即/home/username文件夹</p>
</li>
<li><p>root</p>
<p>[xxx@xxx <del>]#，命令提示符和普通用户不一样，且</del>代表/root文件夹</p>
</li>
</ul>
<h3 id="执行命令的查询路径PATH"><a href="#执行命令的查询路径PATH" class="headerlink" title="执行命令的查询路径PATH"></a>执行命令的查询路径PATH</h3><ul>
<li><p>概念</p>
<p>在终端执行命令的时候，其实由一个同名的可执行文件存在。系统会按照PATH的设置去每个PATH定义的目录下查询可执行文件，如果有多个同名的可执行文件，先查到的可执行文件先执行。（当涉及到别名等其他情况时情况会更复杂，详见<code>Shell-》Bash Shell环境-》路径与命令查找顺序</code>）</p>
</li>
<li><p>查看PATH</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">echo</span> <span class="token environment constant">$PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>每个目录之间以冒号(:)隔开，有顺序之分。</p>
</li>
<li><p>一些事项</p>
<ul>
<li>不同身份用户默认的PATH不同，默认能够随意执行的命令也不同</li>
<li><strong>使用绝对路径或相对路径直接指定命令的文件名来执行，会比查询PATH来的正确</strong></li>
</ul>
</li>
</ul>
<h3 id="开关机相关命令"><a href="#开关机相关命令" class="headerlink" title="开关机相关命令"></a>开关机相关命令</h3><ul>
<li><p>将数据同步写入硬盘</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sync</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>退出登录</p>
<p>注销Linux，退出登录状态。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">exit</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>关机</p>
<pre class="line-numbers language-shel" data-language="shel"><code class="language-shel">shutdown
poweroff<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li><p>重启</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">reboot</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<h3 id="基础操作命令"><a href="#基础操作命令" class="headerlink" title="基础操作命令"></a>基础操作命令</h3><p>​    在Linux中，不一样的大小写代表不同命令，即<strong>大小写敏感</strong>。</p>
<ul>
<li><p>显示日期和时间</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">data<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>显示日历</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">cal</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>简单计算器</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">bc</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<h3 id="重要的热键"><a href="#重要的热键" class="headerlink" title="重要的热键"></a>重要的热键</h3><ul>
<li><p>[Tab]</p>
<p>具有“命令补齐”和“文件补齐”功能。</p>
</li>
<li><p>[Ctrl] + C</p>
<p>中断当前程序。但对于比较重要的命令慎用。</p>
</li>
<li><p>[Ctrl] + D</p>
<p>代表<strong>键盘输入结束</strong>。也可以代替<code>exit</code>命令。</p>
</li>
</ul>
<h3 id="查询命令-man"><a href="#查询命令-man" class="headerlink" title="查询命令 man"></a>查询命令 man</h3><p>​    man是manual（操作说明）的简写。查询的结果页面称为man page。</p>
<ul>
<li><p>man page存放位置</p>
<p>一般为<code>/usr/share/man</code>，可以修改<code>/etc/man.config</code>或<code>/ect/man.conf</code>或<code>/etc/manpath.conf</code>来改变man page的查询路径。</p>
</li>
<li><p>使用方法</p>
</li>
</ul>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">man</span> <span class="token builtin class-name">command</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211222153617005.png" alt="image-20211222153617005" style="zoom:80%;" />

<ul>
<li><p>一些操作</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211222154010796.png" alt="image-20211222154010796"></p>
</li>
<li><p>man page简单解析</p>
<ul>
<li>第一行，命令后面的数字的含义</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211222153704567.png" alt="image-20211222153704567"></p>
<ul>
<li><p>其他参数</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211222154050586.png" alt="image-20211222154050586"></p>
</li>
</ul>
</li>
</ul>
<h3 id="查询命令-info"><a href="#查询命令-info" class="headerlink" title="查询命令 info"></a>查询命令 info</h3><p>​    和man类似，但输出格式有所不同。</p>
<h3 id="查看Linux内核信息命令"><a href="#查看Linux内核信息命令" class="headerlink" title="查看Linux内核信息命令"></a>查看Linux内核信息命令</h3><ul>
<li>查看实际的内核版本</li>
</ul>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">uname</span> -r<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查看distribution信息</li>
</ul>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">lsb_release -a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="清除界面显示"><a href="#清除界面显示" class="headerlink" title="清除界面显示"></a>清除界面显示</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">clear</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h1 id="Linux用户管理"><a href="#Linux用户管理" class="headerlink" title="Linux用户管理"></a>Linux用户管理</h1><h2 id="Linux的账号与用户组"><a href="#Linux的账号与用户组" class="headerlink" title="Linux的账号与用户组"></a>Linux的账号与用户组</h2><h3 id="用户标识符"><a href="#用户标识符" class="headerlink" title="用户标识符"></a>用户标识符</h3><p>​    在登录Linux时，是根据ID（UID和GID）来辨认用户，ID和账号的关系存储在**<code>/etc/passwd</code>和<code>/etc/group</code>**文件中。</p>
<p>​    标识符ID分为两种</p>
<ul>
<li>用户ID，UID</li>
<li>用户组ID，GID</li>
</ul>
<h3 id="用户账号"><a href="#用户账号" class="headerlink" title="用户账号"></a>用户账号</h3><h4 id="用户登录shell流程"><a href="#用户登录shell流程" class="headerlink" title="用户登录shell流程"></a>用户登录shell流程</h4><ol>
<li>先查<code>/etc/passwd</code>文件是否有相关账号<ul>
<li>有，查出对应的UID，然后从<code>/etc/group</code>文件读出GID</li>
<li>没有，提示没有账号</li>
</ul>
</li>
<li>核对密码表，从<code>/etc/shadow</code>找出对应账号信息，对比密码是否正确</li>
<li>如果一切都正确，进入shell</li>
</ol>
<h4 id="etc-passwd文件概览"><a href="#etc-passwd文件概览" class="headerlink" title="/etc/passwd文件概览"></a><code>/etc/passwd</code>文件概览</h4><p>每一行都代表一个账号。注意，其中有很多系统账号，不能删除！</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106113429085.png" alt="image-20220106113429085"></p>
<p>一共被<code>:</code>分隔出7个字段</p>
<ol>
<li><p>账号名称</p>
</li>
<li><p>密码</p>
<p>显示<code>x</code>，因为对应密码被放到<code>/etc/shadow</code>文件了</p>
</li>
<li><p>UID</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106113610216.png" alt="image-20220106113610216"></p>
</li>
<li><p>GID</p>
</li>
<li><p>用户信息说明列</p>
</li>
<li><p>主文件夹路径</p>
<p>默认用户在<code>/home/username</code>，root在<code>/root</code></p>
</li>
<li><p>Shell</p>
<p>用户登录的默认shell设置</p>
</li>
</ol>
<h4 id="etc-shadow文件概览"><a href="#etc-shadow文件概览" class="headerlink" title="/etc/shadow文件概览"></a><code>/etc/shadow</code>文件概览</h4><p>每一行都代表一个账号信息</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106113918319.png" alt="image-20220106113918319"></p>
<p>一共被<code>:</code>分隔出9个字段</p>
<ol>
<li><p>账户名称</p>
</li>
<li><p>密码</p>
<p>密码经过加密了</p>
</li>
<li><p>最近更改密码的日期</p>
<p>从1970-01-01开始计算的累加日期</p>
</li>
<li><p>密码不可被更改的天数</p>
<p>相对于第3字段而言的，即为修改密码的间隔时间参数</p>
</li>
<li><p>密码需要修改的天数</p>
<p>相对于第3字段而言的，即为下一次需要修改密码的时间间隔</p>
</li>
<li><p>密码需要修改期限前的警告天数</p>
<p>相对第5字段而言的，发出提醒</p>
</li>
<li><p>密码过期后的账号宽限时间</p>
<p>相对第5字段而言的</p>
</li>
<li><p>账号失效日期</p>
<p>从1970-01-01开始计算的累加日期计算，表示账号在整个日期之后不能使用</p>
</li>
<li><p>保留字段</p>
<p>日后新功能加入使用</p>
</li>
</ol>
<h3 id="用户组设置"><a href="#用户组设置" class="headerlink" title="用户组设置"></a>用户组设置</h3><p>与用户组相关的配置文件在<code>/etc/group</code>和<code>/etc/gshadow</code>中。</p>
<h4 id="etc-group文件概览"><a href="#etc-group文件概览" class="headerlink" title="/etc/group文件概览"></a><code>/etc/group</code>文件概览</h4><p>每一行代表一个用户组</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106114733243.png" alt="image-20220106114733243"></p>
<p>一共被<code>:</code>分隔出4个字段</p>
<ol>
<li><p>用户组名称</p>
</li>
<li><p>用户组密码</p>
<p>显示<code>x</code>，移动到<code>/etc/gshadow</code>文件中</p>
</li>
<li><p>GID</p>
</li>
<li><p>此用户组支持的账号名称</p>
</li>
</ol>
<h4 id="etc-gshadow文件概览"><a href="#etc-gshadow文件概览" class="headerlink" title="/etc/gshadow文件概览"></a><code>/etc/gshadow</code>文件概览</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106115855619.png" alt="image-20220106115855619"></p>
<ol>
<li>用户组名</li>
<li>密码列</li>
<li>用户组管理员的账号</li>
<li>该用户组的所属账号</li>
</ol>
<h4 id="有效与初始用户组"><a href="#有效与初始用户组" class="headerlink" title="有效与初始用户组"></a>有效与初始用户组</h4><ul>
<li><p>初始用户组(initial group)</p>
<p><code>/etc/passwd</code>的GID，是用户登录系统就立刻拥有的用户组。</p>
</li>
<li><p>有效用户组(effective group)</p>
<p>当有多个用户组支持这个用户账号时，若用户新建文件，文件的GID对应的用户组，即为有效用户组</p>
</li>
<li><p>用户组信息查看groups</p>
<p>使用<code>groups</code>命令可以查看所以支持这个账号的用户组，且<strong>第一个列出的用户组就是有效用户组</strong></p>
</li>
<li><p>有效用户组切换newgrp</p>
<p>在已经支持本账号的用户组间切换</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">newgrp groupname<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<h2 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h2><h3 id="新增与删除用户"><a href="#新增与删除用户" class="headerlink" title="新增与删除用户"></a>新增与删除用户</h3><h4 id="新增用户useradd"><a href="#新增用户useradd" class="headerlink" title="新增用户useradd"></a>新增用户useradd</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106162339197.png" alt="image-20220106162339197"></p>
<ul>
<li><p>默认的一些参数</p>
<p>使用<code>useradd -D</code>查看你默认参数，如group、home目录等等。</p>
<p>这些数据由**<code>/etc/default/useradd</code>**提供</p>
</li>
<li><p>UID/GID、密码参数等</p>
<p>来自<code>/etc/login.defs</code>文件</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106162911549.png" alt="image-20220106162911549"></p>
</li>
</ul>
<h4 id="设置密码passwd"><a href="#设置密码passwd" class="headerlink" title="设置密码passwd"></a>设置密码passwd</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106163028254.png" alt="image-20220106163028254"></p>
<h4 id="修改密码参数chage"><a href="#修改密码参数chage" class="headerlink" title="修改密码参数chage"></a>修改密码参数chage</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106163238915.png" alt="image-20220106163238915"></p>
<h4 id="修改账号参数usermod"><a href="#修改账号参数usermod" class="headerlink" title="修改账号参数usermod"></a>修改账号参数usermod</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106163342766.png" alt="image-20220106163342766"></p>
<h4 id="删除用户userdel"><a href="#删除用户userdel" class="headerlink" title="删除用户userdel"></a>删除用户userdel</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106163515317.png" alt="image-20220106163515317"></p>
<p>删除用户的相关数据，主要是：</p>
<ul>
<li>用户账号/密码：<code>/etc/passwd</code>、<code>/etc/shadow</code></li>
<li>用户组相关参数：<code>/etc/group</code>、<code>/etc/gshadow</code></li>
<li>用户个人文件数据：<code>/home/username</code>、<code>/var/spool/mainl/username</code>等等</li>
</ul>
<h4 id="批量新建用户模板"><a href="#批量新建用户模板" class="headerlink" title="批量新建用户模板"></a>批量新建用户模板</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token shebang important">#!/bin/bash</span>
<span class="token comment"># 新建账号，功能包括：</span>
<span class="token comment"># 1. 检查account1.txt文件是否存在，并将该文件内的账号取出</span>
<span class="token comment"># 2. 新建上述文件的账号</span>
<span class="token comment"># 3. 将上述账号的密码修改成强制第一次进入需要修改密码的格式</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/bin:/sbin:/usr/bin:/user/sbin
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> -f account1.txt <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
	<span class="token builtin class-name">echo</span> <span class="token string">"所需要的账号文件不存在，请新建account1.txt，每行一个账号名称"</span>
	<span class="token builtin class-name">exit</span> <span class="token number">1</span>
<span class="token keyword">fi</span>
<span class="token assign-left variable">usernames</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">cat</span> account1.txt<span class="token variable">)</span></span>
<span class="token keyword">for</span> <span class="token for-or-select variable">username</span> <span class="token keyword">in</span> <span class="token variable">$usernames</span>
<span class="token keyword">do</span>
	<span class="token function">useradd</span> <span class="token variable">$username</span>
	<span class="token builtin class-name">echo</span> <span class="token variable">$username</span> <span class="token operator">|</span> <span class="token function">passwd</span> --stdin <span class="token variable">$username</span>
	chage -d <span class="token number">0</span> <span class="token variable">$username</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># account1.txt</span>
std01
std02
std03<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="用户其他功能"><a href="#用户其他功能" class="headerlink" title="用户其他功能"></a>用户其他功能</h3><ul>
<li><p>查看用户相关信息</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106164521828.png" alt="image-20220106164521828"></p>
</li>
<li><p>改变用户相关信息</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106164553425.png" alt="image-20220106164553425"></p>
</li>
<li><p>改变用户的shell</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106164613803.png" alt="image-20220106164613803"></p>
</li>
<li><p>查看UID/GID</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106164651382.png" alt="image-20220106164651382"></p>
</li>
</ul>
<h3 id="新增与删除用户组"><a href="#新增与删除用户组" class="headerlink" title="新增与删除用户组"></a>新增与删除用户组</h3><h4 id="新增用户组groupadd"><a href="#新增用户组groupadd" class="headerlink" title="新增用户组groupadd"></a>新增用户组groupadd</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106164753657.png" alt="image-20220106164753657"></p>
<h4 id="修改用户组参数groupmod"><a href="#修改用户组参数groupmod" class="headerlink" title="修改用户组参数groupmod"></a>修改用户组参数groupmod</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106164836364.png" alt="image-20220106164836364"></p>
<h4 id="删除用户组"><a href="#删除用户组" class="headerlink" title="删除用户组"></a>删除用户组</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106164900521.png" alt="image-20220106164900521"></p>
<p>删除用户组时，必须确保**<code>/etc/passwd</code>内的账号没有任何人使用该用户组作为初始用户组。**</p>
<h4 id="管理用户组"><a href="#管理用户组" class="headerlink" title="管理用户组"></a>管理用户组</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106165143996.png" alt="image-20220106165143996"></p>
<h2 id="ACL权限"><a href="#ACL权限" class="headerlink" title="ACL权限"></a>ACL权限</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>​    ACL（Access Control List），主要的目的是提供**<code>ogu</code>的<code>rxw</code>之外**的具体权限设置。ACL可以针对单一用户、单一文件/目录来进行<code>rwx</code>权限的设置。</p>
<p>​    ACL需要文件系统的支持，Centos默认是启动ACL的，若没有启动，可以：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">mount</span> -o remount,acl /<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​    或者前往<code>/etc/fstab</code>文件修改信息如下：</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106165802144.png" alt="image-20220106165802144"></p>
<h3 id="文件ACL的设置"><a href="#文件ACL的设置" class="headerlink" title="文件ACL的设置"></a>文件ACL的设置</h3><h4 id="设置文件ACL"><a href="#设置文件ACL" class="headerlink" title="设置文件ACL"></a>设置文件ACL</h4><ul>
<li>使用<code>setfacl</code>命令。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106165910502.png" alt="image-20220106165910502"></p>
<ul>
<li><p>acl参数的格式</p>
<p><code>u:用户/用户组:权限</code></p>
<p>若用户字段没有，表示所有者</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">setfacl -m u:username:rwx filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>设置完后，文件的权限会出现<code>+</code></p>
<pre class="line-numbers language-none"><code class="language-none">-rwxr-xr--+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<h4 id="查看文件ACL"><a href="#查看文件ACL" class="headerlink" title="查看文件ACL"></a>查看文件ACL</h4><ul>
<li><p>使用<code>getfacl</code>命令</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">getfacl filename <span class="token comment">#参数与setfacl相同，这里省略了</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106170627549.png" alt="image-20220106170627549"></p>
<p><strong>其中mask是文件的最大范围权限！</strong></p>
</li>
</ul>
<h2 id="用户身份切换"><a href="#用户身份切换" class="headerlink" title="用户身份切换"></a>用户身份切换</h2><p>​    在不同用户身份切换，一般是普通用户和root的切换</p>
<h3 id="su"><a href="#su" class="headerlink" title="su"></a>su</h3><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106171040573.png" alt="image-20220106171040573"></p>
<p>​    <strong>切换root的时候，需要输入root的密码</strong></p>
<ul>
<li><p>su后不接参数</p>
<p>表示使用non-login shell的方式登录root，很多原本的变量不会改变，如PATH等。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106171302965.png" alt="image-20220106171302965"></p>
</li>
<li><p>su后接<code>-</code></p>
<p>代表使用login shell的方式登录root，环境完全变为root环境</p>
</li>
<li><p>使用<code>exit</code>退出su环境</p>
</li>
</ul>
<h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106171606965.png" alt="image-20220106171606965"><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106171614502.png" alt="image-20220106171614502"></p>
<ul>
<li><p><strong>切换root的时候，不需要root密码，输入自己的密码即可，且仅有/etc/sudoers的用户才能执行sudo命令</strong>。</p>
</li>
<li><p>设置sudo权限使用<code>visudo</code>命令。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106172009357.png" alt="image-20220106172009357"></p>
</li>
</ul>
<h2 id="用户信息传递"><a href="#用户信息传递" class="headerlink" title="用户信息传递"></a>用户信息传递</h2><h3 id="查询用户在线信息"><a href="#查询用户在线信息" class="headerlink" title="查询用户在线信息"></a>查询用户在线信息</h3><ul>
<li><p><code>w</code>/<code>who</code></p>
<p>查看目前已登录系统的用户</p>
</li>
<li><p><code>last</code></p>
<p>查询近来登陆者信息</p>
</li>
<li><p><code>lastlog</code></p>
<p>读取<code>/var/log/lastlog</code>文件，查询每个账号的最近登录时间</p>
</li>
</ul>
<h3 id="用户对谈"><a href="#用户对谈" class="headerlink" title="用户对谈"></a>用户对谈</h3><ul>
<li><p>write</p>
<p>给某个用户写消息</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106172732376.png" alt="image-20220106172732376"></p>
</li>
<li><p>mesg</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mesg n <span class="token comment">#拒绝接收消息，但root的消息不可抵挡</span>
mesg y <span class="token comment">#接收消息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li><p>wall</p>
<p>对所有系统用户广播消息</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">wall messagecontent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<h3 id="用户邮箱"><a href="#用户邮箱" class="headerlink" title="用户邮箱"></a>用户邮箱</h3><p>​    每个Linux用户都有一个mailbox</p>
<p>​    mailbox在<code>/var/spool/mail/username</code>文件</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106173200918.png" alt="image-20220106173200918"></p>
<h1 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h1><h2 id="文件系统与磁盘管理"><a href="#文件系统与磁盘管理" class="headerlink" title="文件系统与磁盘管理"></a>文件系统与磁盘管理</h2><p>​    Linux使用Ext2/Ext3作为文件系统。其中EXT2是Linux最传统的磁盘文件系统。</p>
<h3 id="文件系统结构"><a href="#文件系统结构" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><h4 id="不同的OS使用不同文件系统"><a href="#不同的OS使用不同文件系统" class="headerlink" title="不同的OS使用不同文件系统"></a>不同的OS使用不同文件系统</h4><p>​    磁盘分区后，需要进行<strong>格式化</strong>。因为每种操作系统所设置的文件属性/权限并不相同，为了存放这些文件所需的数据，因此需要将分区进行格式化，以成为操作系统能够利用的文件系统格式。Windows并不认识Linux的Ext2文件系统。</p>
<ul>
<li>Windows 98，使用FAT或FAT16文件系统</li>
<li>Windows 2000以后，使用NTFS文件系统</li>
<li>Linux，使用<strong>Linux second extended file system</strong>(Ext2fs)文件系统</li>
</ul>
<h4 id="文件系统位置"><a href="#文件系统位置" class="headerlink" title="文件系统位置"></a>文件系统位置</h4><p>​    传统磁盘，一个分区只能被格式化为一个文件系统。</p>
<p>​    但由于LVM与软磁盘阵列(software raid)，这些技术可以将一个分区格式化为多个文件系统（例如LVM），也能够将多个分区合成一个文件系统（LVM，RAID）。</p>
<p>​    通常我们可以称呼<strong>一个可被挂载的数据为一个文件系统而不是一个分区</strong>。</p>
<h4 id="Ext2底层结构"><a href="#Ext2底层结构" class="headerlink" title="Ext2底层结构"></a>Ext2底层结构</h4><ul>
<li>Super block：记录文件系统的整体信息，包括inode/block的总量、使用量、剩余量，以及文件系统的格式与相关信息等。</li>
<li>inode：记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的block号码</li>
<li>block：实际记录文件的内容，若文件太大时，会占用多个block</li>
</ul>
<p>文件系统先格式化出inode与block的块。系统文件的<strong>属性与权限</strong>数据放置到inode，而inode记录了文件数据的实际放置点的block号码。此时操作系统就据此排列磁盘的阅读顺序。这种方式称为<strong>索引式文件系统</strong>。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211227141949090.png" alt="image-20211227141949090"></p>
<p>​    Ext2文件系统在格式化的时候，区分为多个块组（block group)的，每个块组都有独立的inode/block/superblock系统。<strong>文件系统最前面有一个启动扇区（boot sector)，这个启动扇区可以安装引导装载程序</strong>。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211227142959039.png" alt="image-20211227142959039"></p>
<ul>
<li><p>data block（数据块）</p>
<p>是用来放置文件内容的地方。在Ext2文件系统中所支持的block大小有1KB，2KB，4KB。在格式化时，block的大小和编号就固定了。不同block大小，对文件系统有些影响：</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211227143757121.png" alt="image-20211227143757121"></p>
<p>每个block内最多只能放置一个文件的数据：</p>
<ul>
<li>如果文件大于block的大小，则一个文件会占用多个block数量</li>
<li>若文件小于block，则该block的剩余空间就不能够再被使用了（磁盘空间会浪费）。</li>
</ul>
</li>
<li><p>inodetable(inode表格)</p>
<p>inode的数量和大小在格式化的时候也被固定，除了用来放文件的属性和权限外，还具有下列特性：</p>
<ul>
<li>每个inode大小均固定为128bytes</li>
<li>每个文件都仅会占用一个inode而已。<strong>所以文件系统能够创建的文件数量与inode的数量有关</strong>。</li>
</ul>
<p>inode记录block号码的区域定义为<strong>12个直接记录区、1个间接记录区、1个双间接记录区、1个三间记录区</strong>。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211227144546633.png" alt="image-20211227144546633"></p>
</li>
<li><p>Superblock（超级块）</p>
<p>记录整个文件系统相关信息的地方：</p>
<ul>
<li>block与inode的总量</li>
<li>未使用与已使用的inode/block数量</li>
<li>block与inode的大小</li>
<li>文件系统的挂载时间、最近一次写入数据的时间、最近一次检验磁盘(fsck)的时间等文件系统的相关信息</li>
<li>一个valid bit数值，若此文件系统已被挂载，则valid bit为0；若未被挂载，则valid bit为1。</li>
</ul>
<p><strong>一般来说，superblock的大小为1024bytes</strong>。一个文件一般应该仅有一个superblock。处理第一个block group含有superblock外，后续的block group不一定含有superblock，若含有则该superblock主要是作为第一个block group内的备份，可以进行superblock的救援。</p>
</li>
<li><p>File system Description（文件系统描述说明）</p>
<p>可以描述每个block group的开始与结束的block号码，以及说明每个区段(superblock，bitmap，inodemap, data block)分别介于哪一个block号码之间。</p>
</li>
<li><p>block bitmap(块对照表)</p>
<p>从block bitmap中可以知道哪些block是空的，方便新建文件</p>
<p>删除文件时，在block bitmap中对应的block号码的标志改为“未使用中”。</p>
</li>
<li><p>inode bitmap(inode对照表)</p>
<p>与block bitmap类似，只不过是记录inode的信息。</p>
</li>
</ul>
<h4 id="U盘底层结构"><a href="#U盘底层结构" class="headerlink" title="U盘底层结构"></a>U盘底层结构</h4><p>​    U盘（闪存），使用文件系统一般为FAT格式。FAT没有inode，它将每个block号码都记录在前一个block当中。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211227142603771.png" alt="image-20211227142603771"></p>
<h4 id="与目录树关系"><a href="#与目录树关系" class="headerlink" title="与目录树关系"></a>与目录树关系</h4><ul>
<li><p>目录</p>
<p>ext2分配一个inode和至少一块block。</p>
<p>block里面记录在整个目录下的文件名与文件名占用的inode号码。</p>
<p><strong>文件系统最顶层的目录的inode一般为2号</strong>。</p>
</li>
<li><p>文件</p>
<p>ext3分配一个inode和多个block记录文件内容。</p>
</li>
</ul>
<h4 id="与内存的交互"><a href="#与内存的交互" class="headerlink" title="与内存的交互"></a>与内存的交互</h4><p>​    Linux使用异步处理（asynchronously）来解决读写磁盘慢的问题。</p>
<ul>
<li>当系统文件到内存后，若文件没有被改动过，则内存区段的文件被设置为clean</li>
<li>当更改过后，内存中的数据被设置为Dirty。所有的操作都在内存中执行，并没有写入磁盘。系统会不定时将内存中设置为Dirty的数据写会磁盘。也可以使用<code>sync</code>强制写入磁盘。</li>
</ul>
<h3 id="文件压缩与打包"><a href="#文件压缩与打包" class="headerlink" title="文件压缩与打包"></a>文件压缩与打包</h3><h4 id="文件解压缩技术"><a href="#文件解压缩技术" class="headerlink" title="文件解压缩技术"></a>文件解压缩技术</h4><ul>
<li><p>定义</p>
<p>由于二进制的0和二进制文件一些重复数据可以进行统计记录的原因，文件空间并不是完全被填满的。</p>
</li>
<li><p>压缩比</p>
<p>压缩前与压缩后的文件所占用的磁盘空间大小的比值</p>
</li>
<li><p>Linux常见压缩文件后缀</p>
<p><strong>compress、gizp、bzip都是对单一文件进行压缩</strong></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211229154418756.png" alt="image-20211229154418756"></p>
</li>
</ul>
<h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><p>​    将多个文件后目录包成一个大文件的命令功能。<br>​    <code>tar</code>命令，除了打包外，还支持通过gzip/bzip2进行压缩。</p>
<h3 id="完整备份和恢复"><a href="#完整备份和恢复" class="headerlink" title="完整备份和恢复"></a>完整备份和恢复</h3><p>​    使用<code>dump</code>命令可以对<strong>整个文件系统备份</strong>，也可以对<strong>单个目录备份</strong>。在多次备份中，后一次备份只备份与前一次备份的<strong>有变化的文件</strong>。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211229160858256.png" alt="image-20211229160858256"></p>
<p>​    使用`restore命令可以恢复系统的数据</p>
<h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><h4 id="新增磁盘步骤"><a href="#新增磁盘步骤" class="headerlink" title="新增磁盘步骤"></a>新增磁盘步骤</h4><ol>
<li>对磁盘进行分区，以新建可用的分区</li>
<li>对分区进行格式化，以创建系统可用的文件系统，并进行检验</li>
<li>在Linux上，需要创建挂载点（目录），并进行挂载</li>
</ol>
<h4 id="设置开机挂载"><a href="#设置开机挂载" class="headerlink" title="设置开机挂载"></a>设置开机挂载</h4><p>​    在<code>/etc/fstab</code>里面设置挂载相关信息。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211229150611105.png" alt="image-20211229150611105"></p>
<p>​    其中第4列是一些特殊的文件系统参数(mount参数设置也有见)，如下：</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211229151139984.png" alt="image-20211229151139984"></p>
<p>​    第5列是指示“能否被dump备份命令使用”</p>
<blockquote>
<p>0：不做dump备份</p>
<p>1：每天进行dump操作</p>
<p>2：不定日期的dump备份操作</p>
</blockquote>
<p>​    第6列是“是否以fsck检验扇区”</p>
<blockquote>
<p>0：不要检验</p>
<p>1：最早检验</p>
</blockquote>
<h4 id="特殊设备挂载"><a href="#特殊设备挂载" class="headerlink" title="特殊设备挂载"></a>特殊设备挂载</h4><ul>
<li><p>镜像文件直接挂载</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211229151922645.png" alt="image-20211229151922645"></p>
</li>
<li><p>创建大文件以制作loop设备文件挂载</p>
<p>对大文件格式化+挂载</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">mkfs</span> -t ext3 /home/loopdev

<span class="token function">mount</span> -o loop /home/loopdev /media/cdrom/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h4 id="相关配置文件"><a href="#相关配置文件" class="headerlink" title="相关配置文件"></a>相关配置文件</h4><p>挂载相关配置文件</p>
<ul>
<li><p>Linux支持的文件系统的驱动</p>
<p><code>/lib/modules/$(uname -r)/kernel/fs/</code></p>
</li>
<li><p>系统指定的测试（默认）挂载文件系统类型</p>
<p><code>/etc/filesystems</code></p>
</li>
<li><p>系统已经加载的文件系统类型</p>
<p><code>/proc/filesystems</code></p>
</li>
<li><p>挂载信息设置<code>etc/fstab</code>、<code>/etc/mtab</code>和<code>/proc/mounts</code></p>
</li>
</ul>
<h2 id="文件属性与权限"><a href="#文件属性与权限" class="headerlink" title="文件属性与权限"></a>文件属性与权限</h2><p>​    任何一个文件都具有User、Group和Others 三种等级权限。root可以查看所有文件。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211223104508097.png" alt="image-20211223104508097"></p>
<h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><h4 id="属性查看"><a href="#属性查看" class="headerlink" title="属性查看"></a>属性查看</h4><ul>
<li><p>使用<code>ls -al</code>命令可以查看当前文件下所有的文件详细的属性与权限。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211223104925835.png" alt="image-20211223104925835"></p>
</li>
<li><p>参数</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211223105504819.png" alt="image-20211223105504819"></p>
<table>
<thead>
<tr>
<th>权限</th>
<th>连接</th>
<th>所有者</th>
<th>用户组</th>
<th>文件容量</th>
<th>修改日期</th>
<th>文件名</th>
</tr>
</thead>
<tbody><tr>
<td>drwx——</td>
<td>3</td>
<td>root</td>
<td>root</td>
<td>4096</td>
<td>Sep 5 10:37</td>
<td>.gconf</td>
</tr>
<tr>
<td>-rw-r–r–</td>
<td>1</td>
<td>root</td>
<td>root</td>
<td>42304</td>
<td>Sep 4 18:26</td>
<td>install.log</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="属性解析"><a href="#属性解析" class="headerlink" title="属性解析"></a>属性解析</h4><ul>
<li><p>第一列，文件类型与权限</p>
<p>一共10个字符。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211223105515659.png" alt="image-20211223105515659"></p>
<p>第一个字符代表文件是“目录、文件或链接文件等”</p>
<ul>
<li><p>[d]是目录</p>
</li>
<li><p>[-]是文件</p>
</li>
<li><p>[l]表示连接文件（linkfile）</p>
<p>有两种连接文件的方式：</p>
<ul>
<li><p>hard link（硬连接/实际连接）</p>
<p>在某个目录下新建一条<strong>文件名连接到某inode号码</strong>的关联记录</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211227155701119.png" alt="image-20211227155701119"></p>
<p>有两个限制：不能跨文件系统，不能连接到目录</p>
</li>
<li><p>symbolic link（符号连接，即快捷方式）</p>
<p>创建一个单独的文件，这个文件会让数据的读取指向它连接的那个文件的文件名。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211227160109388.png" alt="image-20211227160109388"></p>
</li>
</ul>
</li>
<li><p>[b]表示可供存储的接口设备</p>
</li>
<li><p>[c]表示串行端口设备，如键盘、鼠标等</p>
</li>
</ul>
<p>后面9个字符，3个分为一组”rwx”的组合，r为可读，w为可写，x为可执行。如果没有相应权限，用[-]代替。</p>
<ul>
<li>第一组，<strong>文件所有者的权限</strong></li>
<li>第二组，<strong>用户组的权限</strong></li>
<li>第三组，<strong>其他人的权限</strong></li>
</ul>
<p><strong>特别注意这些权限对于文件和目录的意义</strong>:</p>
<ul>
<li><p>对于文件的意义</p>
<p>特别对于w权限，具有<strong>写入、编辑、新增、修改</strong>文件的内容的权限，但<strong>并不具备删除该文件本身的权限</strong>。</p>
</li>
<li><p>对于目录的意义</p>
<ul>
<li><p>r权限，表示可以读取目录下的文件名数据</p>
</li>
<li><p>w权限，表示具有更改目录结构列表的权限，包括：</p>
<ul>
<li>新建新的文件和目录</li>
<li>删除文件和目录</li>
<li>重命名文件和目录</li>
<li>转移该目录内的文件、目录位置</li>
</ul>
</li>
<li><p>x权限，表示用户能否进入该目录成为工作目录</p>
<p>即cd命令能否进入</p>
</li>
</ul>
</li>
</ul>
<p><strong>总而言之</strong>：</p>
<blockquote>
<ul>
<li><p>让用户能进入某目录成为“可工作目录”的基本权限：</p>
<ol>
<li>可使用的命令：`cd等切换工作目录命令</li>
<li>目录所需权限：用户对这个目录至少具有<code>x</code>权限</li>
<li>额外需求：如果用户想要在这个目录使用<code>ls</code>，则还需要<code>r</code>权限</li>
</ol>
</li>
<li><p>用户在某个目录内读取一个文件的基本权限：</p>
<ol>
<li>可使用的命令：<code>cat</code>、<code>more</code>等命令</li>
<li>目录所需权限：用户对这个至少具有<code>x</code>权限</li>
<li>文件所需权限：用户对文件至少需要具有<code>r</code>的权限才行</li>
</ol>
</li>
<li><p>让用户可以修改一个文件的基本权限：</p>
<ol>
<li>可使用的命令：<code>nano</code>、<code>vim</code>等编辑器</li>
<li>目录所需权限：用户在该文件所在的目录至少要有x权限</li>
<li>文件所需权限：用户对该文件至少要有<code>rw</code>权限</li>
</ol>
</li>
<li><p>让一个用户可以创建一个文件的基本权限：</p>
<p>目录所需权限：用户再该目录要具有<code>wx</code>权限，特别是<code>w</code>权限</p>
</li>
<li><p>让用户进入某目录并执行该目录下的命令的基本权限：</p>
<ol>
<li>目录所需权限：用户在该目录至少具有<code>x</code>权限</li>
<li>文件所需权限：用户在该文件至少需要有<code>x</code>权限</li>
</ol>
</li>
</ul>
</blockquote>
</li>
<li><p>第二列，有多少文件名连接到此节点</p>
<p>每个文件都会将权限与属性记录到文件系统的i-node中。这个属性记录有多少不同的文件名连接到相同的一个i-node号码。</p>
</li>
<li><p>第三列，表示文件所有者账号</p>
</li>
<li><p>第四列，表示文件的所属用户组</p>
</li>
<li><p>第五列，文件容量的大小，默认为<strong>B</strong></p>
</li>
<li><p>第六列，这个文件的创建文件日期或最近的修改日期</p>
<p>​    特别注意一下文件的时间，Linux下面会记录许多的时间参数，其中有三个主要的变动时间。<strong>ls默认显示的是mtime</strong>。</p>
<ul>
<li><p>modification time(mtime)</p>
<p>文件的“内容数据”（不是文件属性或权限）改变时，更新mtime</p>
</li>
<li><p>status time(ctime)</p>
<p>文件的“状态”（权限或属性被修改等）改变时，更新ctime</p>
</li>
<li><p>access time(atime)</p>
<p>当“文件的内容被读取”（如使用cat命令)时，更新atime</p>
</li>
</ul>
</li>
<li><p>第七列，文件名。</p>
<p>隐藏文件，文件名有个<code>.</code></p>
</li>
</ul>
<h3 id="改变文件属性与权限"><a href="#改变文件属性与权限" class="headerlink" title="改变文件属性与权限"></a>改变文件属性与权限</h3><h4 id="改变文件所属用户组-chgrp"><a href="#改变文件所属用户组-chgrp" class="headerlink" title="改变文件所属用户组 chgrp"></a>改变文件所属用户组 chgrp</h4><p>​    注意，改变后的组名要在<code>/etc/group</code>文件中才行。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">chgrp</span> <span class="token punctuation">[</span>-R<span class="token punctuation">]</span> groupname filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="改变文件所有者-chown"><a href="#改变文件所有者-chown" class="headerlink" title="改变文件所有者 chown"></a>改变文件所有者 chown</h4><p>​    注意，改变后的用户要在<code>/etc/password</code>文件中才行。此外，还可以顺便改变用户组。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">chown</span> <span class="token punctuation">[</span>-R<span class="token punctuation">]</span> username filenmae

<span class="token function">chown</span> <span class="token punctuation">[</span>-R<span class="token punctuation">]</span> username:groupname filename<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>​    使用环境，如<code>cp</code>命令，复制文件时，会同时复制执行者的属性与权限，可能需要改变权限。</p>
<h4 id="改变文件的权限-chmod"><a href="#改变文件的权限-chmod" class="headerlink" title="改变文件的权限 chmod"></a>改变文件的权限 chmod</h4><p>​    用来改变文件的权限，有两种方式：数字、符号。</p>
<ul>
<li><p>数字类型</p>
<p>使用数字来代替<code>rwx</code>。</p>
<ul>
<li>r:4</li>
<li>w:2</li>
<li>x:1</li>
<li>-:0</li>
</ul>
<p>每组权限<code>rwx</code>的权限数字，是对应的数字相加。如：</p>
<blockquote>
<p>owner = rwx = 4 + 2 + 1 = 7</p>
<p>group = rwx = 4 + 2 + 1 = 7</p>
<p>others = — = 0 + 0 +0</p>
</blockquote>
<p>命令使用方式：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">chmod</span> <span class="token punctuation">[</span>-R<span class="token punctuation">]</span> xyz filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>符号类型</p>
<p>使用u, g, o分别代替user 、group、others三种身份，a代表all，即全部身份。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211223112151967.png" alt="image-20211223112151967"></p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">chmod</span> <span class="token assign-left variable">u</span><span class="token operator">=</span>rwx, <span class="token assign-left variable">go</span><span class="token operator">=</span>rx filename

<span class="token function">chmod</span> a+x filename<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="文件的默认权限"><a href="#文件的默认权限" class="headerlink" title="文件的默认权限"></a>文件的默认权限</h3><p>​    在新建文件或目录时候的权限默认值，由umask指定。</p>
<p>​    umask是四个数字，如<code>0022</code>，与一般权限有关的后三个数字，分别表示user、group、others需要<strong>在默认权限的基础上拿掉的权限</strong>。比如这里group和others需要去掉<code>w</code>权限。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211224112749847.png" alt="image-20211224112749847"></p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">umask</span> xxx <span class="token comment">#直接设置ugo需要去掉的权限</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="默认情况的权限"><a href="#默认情况的权限" class="headerlink" title="默认情况的权限"></a>默认情况的权限</h4><ul>
<li><p>若用户创建“文件”，<strong>默认没有可执行<code>x</code>权限</strong>，只有<code>rw</code>权限，所有最大为666，即默认权限为：</p>
<p><code>-rw-rw-rw-</code></p>
</li>
<li><p>若用户创建“目录”，默认为777，即</p>
<p><code>drwxrwxrwx</code></p>
</li>
</ul>
<h4 id="设置umask后的权限"><a href="#设置umask后的权限" class="headerlink" title="设置umask后的权限"></a>设置umask后的权限</h4><p>​    比如若umask为<code>0022</code></p>
<ul>
<li><p>新建文件时</p>
<p><code>-rw-rw-rw-</code> - <code>-----w--w-</code> = <code>-rw-r--r--</code></p>
</li>
<li><p>新建目录时</p>
<p><code>drwxrwxrwx</code> - <code>d----w--w-</code> = <code>drwxr-xr-x</code></p>
</li>
</ul>
<h3 id="文件的隐藏属性"><a href="#文件的隐藏属性" class="headerlink" title="文件的隐藏属性"></a>文件的隐藏属性</h3><h4 id="设置文件的隐藏属性"><a href="#设置文件的隐藏属性" class="headerlink" title="设置文件的隐藏属性"></a>设置文件的隐藏属性</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211224113249637.png" alt="image-20211224113249637"></p>
<h4 id="显示文件隐藏属性"><a href="#显示文件隐藏属性" class="headerlink" title="显示文件隐藏属性"></a>显示文件隐藏属性</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211224113314101.png" alt="image-20211224113314101"></p>
<h3 id="文件特殊权限"><a href="#文件特殊权限" class="headerlink" title="文件特殊权限"></a>文件特殊权限</h3><p>​    在Linux的一些特殊文件的权限里，如<code>/tmp</code>、<code>/usr/bin/passwd</code>等，有<code>s</code>、<code>t</code>等等权限。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211224133849294.png" alt="image-20211224133849294"></p>
<h4 id="SUID"><a href="#SUID" class="headerlink" title="SUID"></a>SUID</h4><p>​    <code>s</code>出现在文件所有者的<code>x</code>权限上时，称为Set UID，简称SUID权限。提供的功能：</p>
<ul>
<li>SUID权限仅对<strong>二进制</strong>程序有效</li>
<li>执行者对于该程序具有<code>x</code>的执行权限</li>
<li>本权限仅在执行该程序过程中有效</li>
<li>执行者将具有该程序所有者的权限</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211224134144319.png" alt="image-20211224134144319"></p>
<h4 id="SGID"><a href="#SGID" class="headerlink" title="SGID"></a>SGID</h4><p>​    <code>s</code>出现在文件用户组的<code>x</code>权限上时，称为Set GID，简称SGID权限。如<code>/usr/bin/locate</code>文件。</p>
<p>对于<strong>文件</strong>提供的功能：</p>
<ul>
<li>SGID对二进制程序有用</li>
<li>程序执行者对该程序具有<code>x</code>权限</li>
<li>执行者在执行过程中获得该程序用户组的支持</li>
</ul>
<p>对于<strong>目录</strong>提供的功能：</p>
<ul>
<li>用户若对于此目录具有<code>rx</code>权限，则该用户能进入目录</li>
<li>用户对此目录的有效用户组会变成该目录的用户组</li>
<li>若用户再此目录下具有<code>w</code>权限，则用户创建的新文件的用户组与此目录的用户组相同</li>
</ul>
<h4 id="SBIT"><a href="#SBIT" class="headerlink" title="SBIT"></a>SBIT</h4><p>​    Sticky Bit(SBIT)目前只针对目录有效，作用是：</p>
<blockquote>
<p>若用户对目录具有<code>wx</code>权限，当用户在该目录下创建文件或目录时，仅有自己与root才有权利删除该文件。</p>
</blockquote>
<h4 id="特殊权限的设置"><a href="#特殊权限的设置" class="headerlink" title="特殊权限的设置"></a>特殊权限的设置</h4><p>​    依然使用<code>chmod</code>命令，但需要在之前数字方式的基础上，使用4个数字修改权限，最前面的数字就是代表<code>SUID</code>、<code>SGID</code>、<code>SBIT</code>的权限。</p>
<ul>
<li>SUID: 4</li>
<li>SGID: 2</li>
<li>SBIT: 1</li>
</ul>
<h2 id="Linux目录详解"><a href="#Linux目录详解" class="headerlink" title="Linux目录详解"></a>Linux目录详解</h2><p>​    Filesystem Hierarchy Standard(FHS)标准，规定每个特定的Linux目录下应该要放置什么样子的数据。FHS定义出三层目录：</p>
<ul>
<li>/ ，根目录，与开机系统有关</li>
<li>/usr , Unix software resource，与软件安装有关</li>
<li>/var，variable，与系统运作过程有关</li>
</ul>
<h3 id="四种交互作用形态"><a href="#四种交互作用形态" class="headerlink" title="四种交互作用形态"></a>四种交互作用形态</h3><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211223114038459.png" alt="image-20211223114038459"></p>
<ul>
<li><p>可分享的</p>
<p>分享给其他系统挂载使用的目录</p>
</li>
<li><p>不可分享的</p>
<p>仅与自身机器有关，不适合分享给其他主机</p>
</li>
<li><p>不变的</p>
<p>有些数据不经常变动，跟随distribution而不变动。如函数库、文件说明文件等。</p>
</li>
<li><p>可变动的</p>
<p>进程改变的数据，如登录文件等。</p>
</li>
</ul>
<h3 id="常见目录"><a href="#常见目录" class="headerlink" title="常见目录"></a>常见目录</h3><h4 id="根目录-的内容"><a href="#根目录-的内容" class="headerlink" title="根目录(/)的内容"></a>根目录(/)的内容</h4><p>​    FHS建议，根目录所在分区应该越小越好，且应用程序所安装的软件最好不要与根目录放在同一个分区。</p>
<p>​    根目录与开机有关，<strong>开机过程中仅有根目录会被挂载</strong>，其他分区在开机后陆续进行挂载。下面这些目录一定要和根目录放在同一分区下：</p>
<ul>
<li>/etc 配置文件</li>
<li>/bin 重要执行文件</li>
<li>/dev 需要的设备文件</li>
<li>/lib 执行文件所需要的函数库与内核所需的模块</li>
<li>/sbin 重要的系统执行文件</li>
</ul>
<p>​    根目录下的常见子目录如下：</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211223114837952.png" alt="image-20211223114837952"></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211223114851313.png" alt="image-20211223114851313"></p>
<h4 id="usr的内容"><a href="#usr的内容" class="headerlink" title="/usr的内容"></a><code>/usr</code>的内容</h4><p>​    是所有系统默认软件的安装目录。/usr的子目录建议有下列：</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211223151450942.png" alt="image-20211223151450942"></p>
<p>​    </p>
<h4 id="var内容"><a href="#var内容" class="headerlink" title="/var内容"></a><code>/var</code>内容</h4><p>​    在系统运行之后逐渐填满容量的目录，包括缓存、登录文件、软件运行所产生的文件等。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211223152046728.png" alt="image-20211223152046728"></p>
<h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><ul>
<li>绝对路径：由根目录(/)开始写起的文件名或目录名称</li>
<li>相对路径：相对当前路径的文件名写法。<code>./xx</code>，<code>../xx</code>，<code>xx/xx</code>等<ul>
<li><code>.</code>代表当前目录</li>
<li><code>..</code>代表上一层目录</li>
</ul>
</li>
</ul>
<h2 id="Linux文件系统命令"><a href="#Linux文件系统命令" class="headerlink" title="Linux文件系统命令"></a>Linux文件系统命令</h2><h3 id="目录相关命令"><a href="#目录相关命令" class="headerlink" title="目录相关命令"></a>目录相关命令</h3><h4 id="切换目录cd"><a href="#切换目录cd" class="headerlink" title="切换目录cd"></a>切换目录cd</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">cd</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="显示当前目录pwd"><a href="#显示当前目录pwd" class="headerlink" title="显示当前目录pwd"></a>显示当前目录pwd</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">pwd</span> <span class="token punctuation">[</span>-P<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>-P参数显示出当前路径，而非连接路径</p>
<h4 id="新建目录mkdir"><a href="#新建目录mkdir" class="headerlink" title="新建目录mkdir"></a>新建目录mkdir</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">mkdir</span> <span class="token punctuation">[</span>-mp<span class="token punctuation">]</span> filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><p>-m 777</p>
<p>配置文件的权限</p>
</li>
<li><p>-p filename1/filename2</p>
<p>递归创建目录</p>
</li>
</ul>
<h4 id="删除一个空的目录rmdir"><a href="#删除一个空的目录rmdir" class="headerlink" title="删除一个空的目录rmdir"></a>删除一个空的目录rmdir</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">rmdir</span> <span class="token punctuation">[</span>-p<span class="token punctuation">]</span> filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>递归删除目录</p>
<h4 id="查看文件与目录ls"><a href="#查看文件与目录ls" class="headerlink" title="查看文件与目录ls"></a>查看文件与目录ls</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211223171658704.png" alt="image-20211223171658704"></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211223171810849.png" alt="image-20211223171810849"></p>
<p>​    其中<code>ls -l</code>命令有个别名为<code>ll</code>。</p>
<h4 id="复制cp"><a href="#复制cp" class="headerlink" title="复制cp"></a>复制cp</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211223171917441.png" alt="image-20211223171917441"></p>
<p>​    特别注意，<strong>在默认的条件中，cp的源文件与目的文件的权限是不同的，目的文件的所有者通常会是命令操作者本身</strong>。</p>
<h4 id="移除rm"><a href="#移除rm" class="headerlink" title="移除rm"></a>移除rm</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211223172715286.png" alt="image-20211223172715286"></p>
<h4 id="移动mv"><a href="#移动mv" class="headerlink" title="移动mv"></a>移动mv</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211223172939196.png" alt="image-20211223172939196"></p>
<h4 id="取路径的文件名basename和目录名称dirname"><a href="#取路径的文件名basename和目录名称dirname" class="headerlink" title="取路径的文件名basename和目录名称dirname"></a>取路径的文件名basename和目录名称dirname</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211223173744142.png" alt="image-20211223173744142"></p>
<h3 id="文件内容相关命令"><a href="#文件内容相关命令" class="headerlink" title="文件内容相关命令"></a>文件内容相关命令</h3><h4 id="从第一开始显示cat"><a href="#从第一开始显示cat" class="headerlink" title="从第一开始显示cat"></a>从第一开始显示cat</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211223174226131.png" alt="image-20211223174226131"></p>
<h4 id="从最后一行开始显示tac"><a href="#从最后一行开始显示tac" class="headerlink" title="从最后一行开始显示tac"></a>从最后一行开始显示tac</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">tac</span> filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="带行号输出nl"><a href="#带行号输出nl" class="headerlink" title="带行号输出nl"></a>带行号输出nl</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211223174807041.png" alt="image-20211223174807041"></p>
<h4 id="一页一页显示more"><a href="#一页一页显示more" class="headerlink" title="一页一页显示more"></a>一页一页显示more</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">more</span> filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>可用的操作：</p>
<ul>
<li>空格键，向下翻一页</li>
<li>Enter，向下滚动一行</li>
<li>/字符串，向下查询“字符串”关键字</li>
<li>:f，立刻显示出文件名以及目前显示的行数</li>
<li>q，立刻离开more，不再显示该文件内容</li>
<li>b或[Ctrl]+b，往回翻页</li>
</ul>
<h4 id="可以往前翻页显示less"><a href="#可以往前翻页显示less" class="headerlink" title="可以往前翻页显示less"></a>可以往前翻页显示less</h4><p>​    在more的功能基础上，加上往前翻页的功能</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">less</span> filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​    可用的操作：</p>
<ul>
<li>空格键，往下翻一页</li>
<li>[PageDown]，往下翻一页</li>
<li>[PageUp]，往上翻一页</li>
<li>/字符串，向下查询“字符串”的功能</li>
<li>?字符串，向上查询“字符串”的功能</li>
<li>n，重复前一个查询（与/或?有关）</li>
<li>N，反向重复前一个查询（与/或?有关）</li>
<li>q，离开less这个程序</li>
</ul>
<h4 id="只看头几行head"><a href="#只看头几行head" class="headerlink" title="只看头几行head"></a>只看头几行head</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211223180110583.png" alt="image-20211223180110583"></p>
<h4 id="只看结尾几行tail"><a href="#只看结尾几行tail" class="headerlink" title="只看结尾几行tail"></a>只看结尾几行tail</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211223180132401.png" alt="image-20211223180132401"></p>
<h4 id="二进制方式读取文件od"><a href="#二进制方式读取文件od" class="headerlink" title="二进制方式读取文件od"></a>二进制方式读取文件od</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211223180349752.png" alt="image-20211223180349752"></p>
<h4 id="修改文件时间或创建新文件touch"><a href="#修改文件时间或创建新文件touch" class="headerlink" title="修改文件时间或创建新文件touch"></a>修改文件时间或创建新文件touch</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211224104756745.png" alt="image-20211224104756745"></p>
<h4 id="查看文件类型file"><a href="#查看文件类型file" class="headerlink" title="查看文件类型file"></a>查看文件类型file</h4><p>​    获取文件的基本数据的类型，如ASCII文件、data文件、binary文件，或是有没有动态函数库(share library)等信息。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">file</span> filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="文件压缩打包命令"><a href="#文件压缩打包命令" class="headerlink" title="文件压缩打包命令"></a>文件压缩打包命令</h3><h4 id="解压缩命令"><a href="#解压缩命令" class="headerlink" title="解压缩命令"></a>解压缩命令</h4><ul>
<li><p>compress</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211229154657937.png" alt="image-20211229154657937"></p>
</li>
<li><p>gzip</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211229154921021.png" alt="image-20211229154921021"></p>
</li>
<li><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211229154947217.png" alt="image-20211229154947217"></p>
</li>
</ul>
<h4 id="打包命令"><a href="#打包命令" class="headerlink" title="打包命令"></a>打包命令</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211229160014952.png" alt="image-20211229160014952"></p>
<p>常用操作：</p>
<ul>
<li><p>压缩</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">tar</span> -jcv -f tarfilename.tar.bz2 filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>查询</p>
<pre class="line-numbers language-shel" data-language="shel"><code class="language-shel">tar -jtv -f tarfilename.tar.bz2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>解压缩</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">tar</span> -jxv -f tarfilename.tar.bz2 -C filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<h3 id="文件-命令的信息查询命令"><a href="#文件-命令的信息查询命令" class="headerlink" title="文件/命令的信息查询命令"></a>文件/命令的信息查询命令</h3><h4 id="脚本文件名查询which"><a href="#脚本文件名查询which" class="headerlink" title="脚本文件名查询which"></a>脚本文件名查询which</h4><p>​    根据PATH环境变量所规范的路径，去查询完整文件名或命令路径。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211227121425091.png" alt="image-20211227121425091"></p>
<h4 id="按文件名查找相关文件whereis-locate-find"><a href="#按文件名查找相关文件whereis-locate-find" class="headerlink" title="按文件名查找相关文件whereis/locate/find"></a>按文件名查找相关文件whereis/locate/find</h4><p>​    这两个命令查询的时候根据<strong>文件数据库</strong>查询，速度会快很多。相对于<code>find</code>命令，是直接去磁盘找。</p>
<ul>
<li><p><code>whereis</code></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211227122111403.png" alt="image-20211227122111403"></p>
</li>
<li><p><code>locate</code></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211227122434362.png" alt="image-20211227122434362"></p>
<p>其中<code>keyword</code>指的是可以根据<code>文件部分名称</code>查找相关的文件。</p>
<ul>
<li>数据库文件：<code>/var/lib/mlocate/</code></li>
<li>更新数据库：<ul>
<li>命令：<code>updatedb</code></li>
<li>配置文件：<code>/etc/updatedb.conf</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>find</code></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211227123151130.png" alt="image-20211227123151130"><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211227123201007.png" alt="image-20211227123201007"><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211227123337769.png" alt="image-20211227123337769"><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211227123420024.png" alt="image-20211227123420024"><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211227123511169.png" alt="image-20211227123511169"></p>
</li>
</ul>
<h3 id="Linux磁盘命令"><a href="#Linux磁盘命令" class="headerlink" title="Linux磁盘命令"></a>Linux磁盘命令</h3><h4 id="查询磁盘每个区段信息dumpe2fs"><a href="#查询磁盘每个区段信息dumpe2fs" class="headerlink" title="查询磁盘每个区段信息dumpe2fs"></a>查询磁盘每个区段信息dumpe2fs</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211227150331559.png" alt="image-20211227150331559"></p>
<h4 id="列出文件系统的整体磁盘使用df"><a href="#列出文件系统的整体磁盘使用df" class="headerlink" title="列出文件系统的整体磁盘使用df"></a>列出文件系统的整体磁盘使用df</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211227154617262.png" alt="image-20211227154617262"></p>
<h4 id="评估文件系统的磁盘使用量du"><a href="#评估文件系统的磁盘使用量du" class="headerlink" title="评估文件系统的磁盘使用量du"></a>评估文件系统的磁盘使用量du</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211227155016624.png" alt="image-20211227155016624"></p>
<h4 id="连接文件ln"><a href="#连接文件ln" class="headerlink" title="连接文件ln"></a>连接文件ln</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211227160403922.png" alt="image-20211227160403922"></p>
<h4 id="磁盘分区fdisk"><a href="#磁盘分区fdisk" class="headerlink" title="磁盘分区fdisk"></a>磁盘分区fdisk</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211229140604320.png" alt="image-20211229140604320"></p>
<p>该命令之后会进入一个交互式环境：</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211229140841468.png" alt="image-20211229140841468"></p>
<h4 id="磁盘格式化mkfs-mke2fs"><a href="#磁盘格式化mkfs-mke2fs" class="headerlink" title="磁盘格式化mkfs/mke2fs"></a>磁盘格式化mkfs/mke2fs</h4><ul>
<li><p>mkfs</p>
<p>进行格式化，创建文件系统</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211229141501494.png" alt="image-20211229141501494"></p>
</li>
<li><p>mke2fs</p>
<p>自定义数据创建文件系统</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211229141838478.png" alt="image-20211229141838478"></p>
</li>
</ul>
<h4 id="磁盘检验fsck-badblocks"><a href="#磁盘检验fsck-badblocks" class="headerlink" title="磁盘检验fsck/badblocks"></a>磁盘检验fsck/badblocks</h4><ul>
<li><p>fsck</p>
<p>检验文件系统是否出错</p>
<p>执行fsck时，<strong>被检查的分区务必不可挂载到系统上！</strong></p>
<p>执行完成后，若系统磁盘有问题会在<strong>挂载点目录</strong>下面创建<code>lost+found</code>目录，存放有问题的数据</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211229142400667.png" alt="image-20211229142400667"></p>
</li>
<li><p>badblocks</p>
<p>检查硬盘或软盘扇区有无坏轨</p>
<p>可以被<code>mke2fs -c 设备文件名</code>命令代替，不常用badblocks。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211229143439923.png" alt="image-20211229143439923"></p>
</li>
</ul>
<h4 id="磁盘挂载mount"><a href="#磁盘挂载mount" class="headerlink" title="磁盘挂载mount"></a>磁盘挂载mount</h4><p>​    挂载是将参数写入<code>/etc/mtab</code>和<code>/proc/mounts</code>文件</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211229143811728.png" alt="image-20211229143811728"></p>
<h4 id="磁盘卸载umount"><a href="#磁盘卸载umount" class="headerlink" title="磁盘卸载umount"></a>磁盘卸载umount</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211229144827724.png" alt="image-20211229144827724"></p>
<h4 id="修改设备文件参数mknod"><a href="#修改设备文件参数mknod" class="headerlink" title="修改设备文件参数mknod"></a>修改设备文件参数mknod</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211229145806337.png" alt="image-20211229145806337"></p>
<h4 id="修改磁盘卷标e2label"><a href="#修改磁盘卷标e2label" class="headerlink" title="修改磁盘卷标e2label"></a>修改磁盘卷标e2label</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211229150006799.png" alt="image-20211229150006799"></p>
<h4 id="更改文件系统类型tune2fs"><a href="#更改文件系统类型tune2fs" class="headerlink" title="更改文件系统类型tune2fs"></a>更改文件系统类型tune2fs</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211229150104697.png" alt="image-20211229150104697"></p>
<h4 id="新建镜像文件mkisofs"><a href="#新建镜像文件mkisofs" class="headerlink" title="新建镜像文件mkisofs"></a>新建镜像文件mkisofs</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211229161135999.png" alt="image-20211229161135999"></p>
<h4 id="光盘刻录cdrecord"><a href="#光盘刻录cdrecord" class="headerlink" title="光盘刻录cdrecord"></a>光盘刻录cdrecord</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20211229161253678.png" alt="image-20211229161253678"></p>
<h1 id="Linux进程"><a href="#Linux进程" class="headerlink" title="Linux进程"></a>Linux进程</h1><h2 id="例行性工作"><a href="#例行性工作" class="headerlink" title="例行性工作"></a>例行性工作</h2><ul>
<li><p>概念</p>
<p>周期性或定时需要完成的事情</p>
</li>
<li><p>Linux的常见例行性工作</p>
<ul>
<li><p>进行日志文件的轮替(log rotate)</p>
</li>
<li><p>日志文件分析logwatch</p>
</li>
<li><p>新建locate数据库</p>
<p>对文件名数据库<code>/var/lib/mlocate/</code>文件进行更新</p>
</li>
<li><p>whatis数据库建立</p>
<p>与man page相关的查询命令的数据库</p>
</li>
<li><p>RPM软件日志文件的新建</p>
<p>软件变动后，文件名的排序、数据库的建立等等</p>
</li>
<li><p>删除临时文件</p>
<p><code>tmpwatch</code>命令进行周期工作，删除软件运行中产生的临时文件</p>
</li>
<li><p>与网路服务有关的分析行为</p>
</li>
</ul>
</li>
</ul>
<h3 id="仅执行一次的工作调度"><a href="#仅执行一次的工作调度" class="headerlink" title="仅执行一次的工作调度"></a>仅执行一次的工作调度</h3><h4 id="启动atd服务"><a href="#启动atd服务" class="headerlink" title="启动atd服务"></a>启动atd服务</h4><p>使用单一工作调度，需要开启atd服务</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">/etc/init.d/atd restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="设置单一工作调度at"><a href="#设置单一工作调度at" class="headerlink" title="设置单一工作调度at"></a>设置单一工作调度at</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107094901902.png" alt="image-20220107094901902"></p>
<ul>
<li><p>at的工作机理</p>
<p>将工作以文本文件的方式写入**<code>/var/spool/at/</code>**目录内，该工作便等待atd服务的取用与执行</p>
</li>
<li><p>at的限制相关文件</p>
<p>可以利用<code>/etc/at.allow</code>和<code>/etc/at.deny</code>进行at的使用限制</p>
<ol>
<li>先寻找<code>/etc/at.allow</code>文件，写入这个文件的用户才能使用at，不在文件中的用户不可以使用（即使没有写入<code>/etc/at.deny</code>文件，也不可以使用）</li>
<li>如果<code>/etc/at.allow</code>文件不存在，就寻找<code>/etc/at.deny</code>这个文件，写在<code>/etc/at.deny</code>文件的用户不可以使用at，没有在<code>/etc/at.deny</code>的用户就可以使用at</li>
<li>如果两个文件都不存在，那么只用root可以使用at命令</li>
</ol>
</li>
<li><p>at的运行</p>
<ul>
<li><p>输入<code>at</code>命令后，会进入at shell环境来让用户执行工作命令。所以，在at shell中最好使用绝对路径来执行相关命令。</p>
</li>
<li><p>at的执行与终端机无关，所以所有的stdout和stderr都会传送到执行者的mailbox</p>
</li>
<li><p>at具有“后台执行”功能</p>
</li>
</ul>
</li>
</ul>
<h4 id="查询当前at工作调度"><a href="#查询当前at工作调度" class="headerlink" title="查询当前at工作调度"></a>查询当前at工作调度</h4><p>使用<code>atq</code>命令即可</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">atq<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="删除任务调度atrm"><a href="#删除任务调度atrm" class="headerlink" title="删除任务调度atrm"></a>删除任务调度atrm</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">atrm <span class="token punctuation">[</span>jobnumber<span class="token punctuation">]</span> <span class="token comment"># jobnumber是atq命令查出的参数</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="CPU空闲时执行工作batch"><a href="#CPU空闲时执行工作batch" class="headerlink" title="CPU空闲时执行工作batch"></a>CPU空闲时执行工作batch</h4><p>​    当<strong>CPU工作负载</strong>（与当前CPU进行切换的进程数量有关）小于0.8时，才进行任务的执行</p>
<p>​    <code>batch</code>是利用at来进行命令的执行，命令使用与at相似</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107101119636.png" alt="image-20220107101119636"></p>
<h3 id="循环执行的工作调度"><a href="#循环执行的工作调度" class="headerlink" title="循环执行的工作调度"></a>循环执行的工作调度</h3><h4 id="启动crond服务"><a href="#启动crond服务" class="headerlink" title="启动crond服务"></a>启动crond服务</h4><p>​    使用<code>crond</code>系统服务来控制的，该服务Linux是默认启动的。</p>
<p>​    <code>crond</code>服务的最低检测限制是“分钟”，所以服务会<strong>每分钟读取<code>/etc/crontab</code>和<code>/var/spool/cron</code>的数据内容</strong>。</p>
<p>​    设置完任务后，如果没有被执行，可以重启crond服务。</p>
<h4 id="设置用户循环工作调度crontab"><a href="#设置用户循环工作调度crontab" class="headerlink" title="设置用户循环工作调度crontab"></a>设置用户循环工作调度crontab</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107101927894.png" alt="image-20220107101927894"></p>
<ul>
<li><p>crontab的工作机理</p>
<p>将工作以文本文件的方式写入**<code>/var/spool/cron/</code>**目录内，该工作便等待crond服务的取用与执行</p>
<p>与此同时，cron执行的每项工作都被记录到<code>/var/log/cron</code>日志文件中</p>
</li>
<li><p>crontab的限制相关文件</p>
<p>与at类似，这里的文件是<code>/etc/cron.allow</code>、<code>/etc/cron.deny</code>。</p>
</li>
<li><p>cron工作的设置格式</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107102546981.png" alt="image-20220107102546981"></p>
<p>输入<code>crontab -e</code>就会进入<code>vi</code>的编辑界面。每项工作一行，可以分为6个字段：</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107102656700.png" alt="image-20220107102656700"></p>
<p>设置参数的一些辅助字符：</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107102743019.png" alt="image-20220107102743019"></p>
</li>
<li><p>查询用户目前的crontab内容</p>
<pre class="line-numbers language-none"><code class="language-none">crontab -l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>删除任务</p>
<p>删除全部工作使用</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">crontab</span> -r<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>删除部分工作，用<code>crontab -e</code>编辑文件删除</p>
</li>
</ul>
<h4 id="设置系统的循环工作调度"><a href="#设置系统的循环工作调度" class="headerlink" title="设置系统的循环工作调度"></a>设置系统的循环工作调度</h4><p>​    通过编辑<code>/etc/crontab</code>文件，即可设置系统例行性工作调度。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107103439790.png" alt="image-20220107103439790"></p>
<h3 id="唤醒停机期间的工作任务"><a href="#唤醒停机期间的工作任务" class="headerlink" title="唤醒停机期间的工作任务"></a>唤醒停机期间的工作任务</h3><ul>
<li><p><code>anacron</code></p>
<p><code>anacron</code>是以天为单位或开机后立刻仅<code>anacron</code>操作，会去检测停机期间应该进行但没有进行的<code>crontab</code>任务，并将该任务执行一遍，然后<code>anacron</code>就会自动停止。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107103817261.png" alt="image-20220107103817261"></p>
</li>
<li><p>运行机理</p>
<p><code>anacron</code>读取时间记录文件(timestamps)，分析现在的时间与时间记录文件所记载的上次执行<code>anacron</code>的时间，两者比较后若发现有区别，那就是在某些时刻没有进行<code>crontab</code>。此时<code>anacron</code>开始执行未进行的<code>crontab</code>任务。</p>
</li>
<li><p>与<code>crontab</code>的关系</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107110721695.png" alt="image-20220107110721695"></p>
</li>
<li><p><code>/etc/anacrontab</code></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107110816360.png" alt="image-20220107110816360"></p>
</li>
</ul>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>​    在Linux系统中，<strong>触发任何一个事件时，系统都会将它定义成为一个进程，并且给予这个进程一个ID，即为PID，同时依据触发这个进程的用户与相关属性关系，给予PID一组有效的权限设置</strong>.</p>
<p>​    执行一个程序或命令，就可以触发事件而得到PID。程序一般是放置在磁盘中，通过用户的执行来触发。触发后会加载到内存中成为一个个体，那就是<strong>进程</strong>。为了操作系统可管理这个进程，进程有执行者的权限属性等参数，并包括进程所需要的脚步用户数据、文件等，最后操作系统再给予一个PID。系统就是通过PID判断进程是否具有权限进行某项工作的。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107111812811.png" alt="image-20220107111812811"></p>
<p>​    进程衍生出来的其他进程一般也会沿用这个进程的相关权限。</p>
<h3 id="子进程与父进程"><a href="#子进程与父进程" class="headerlink" title="子进程与父进程"></a>子进程与父进程</h3><p>​    比如在bash下执行其他命令，这些命令有时候也会被触发成为PID，这个即为子进程，原来的bash环境则为父进程。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107112113431.png" alt="image-20220107112113431"></p>
<ul>
<li><p>子进程与父进程的关系通过<code>PPID</code>参数判断。<code>ps -l</code>命令输入后：<img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107112314853.png" alt="image-20220107112314853"></p>
</li>
<li><p>子进程与父进程的调用</p>
<p>在Linux中称为<code>fork-and-exec</code>流程。</p>
<p>父进程以fork的方式产生一个一模一样的子进程，被复制出来的子进程再以exec的方式来执行实际要进程的进程，最终成为一个子进程的存在。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107112954832.png" alt="image-20220107112954832"></p>
</li>
</ul>
<h3 id="后台进程设置"><a href="#后台进程设置" class="headerlink" title="后台进程设置"></a>后台进程设置</h3><h4 id="后台运行进程"><a href="#后台运行进程" class="headerlink" title="后台运行进程"></a>后台运行进程</h4><ul>
<li><p>丢入bash后台使用<code>&amp;</code></p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">command</span> <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>执行后会给出工作号码和command所触发的PID，如：</p>
<pre class="line-numbers language-none"><code class="language-none">[1] 8400<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>后台的输出信息处理</p>
<p>使用数据流重定向，将数据流重定向到指定文件</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">command</span> <span class="token operator">></span> outfilename <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<h4 id="暂停当前进程并丢到后台"><a href="#暂停当前进程并丢到后台" class="headerlink" title="暂停当前进程并丢到后台"></a>暂停当前进程并丢到后台</h4><p>如正在使用vim编辑文件，临时离开的情况</p>
<p>在vim的一般模式下，使用<code>[Ctrl]+Z</code>，终端会输出类似下列输出</p>
<pre class="line-numbers language-none"><code class="language-none">[1]+ Stopped<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>[1]表示工作号码，<code>+</code>表示最近一个被丢进后台的工作（相对应，<code>-</code>表示最近第二个被丢进后台的工作），Stopped表示进程工作状态处于暂停（相对应，<code>Running</code>表示进程处于后台运行状态）</p>
<h4 id="查看后台进程jobs"><a href="#查看后台进程jobs" class="headerlink" title="查看后台进程jobs"></a>查看后台进程jobs</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107133908349.png" alt="image-20220107133908349"></p>
<h4 id="后台进程拿到前台fg"><a href="#后台进程拿到前台fg" class="headerlink" title="后台进程拿到前台fg"></a>后台进程拿到前台fg</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107134131976.png" alt="image-20220107134131976"></p>
<p><code>fg</code>后不接参数，默认取的是带有<code>+</code>表示的工作</p>
<h4 id="后台进程状态变为运行"><a href="#后台进程状态变为运行" class="headerlink" title="后台进程状态变为运行"></a>后台进程状态变为运行</h4><p>​    <code>[Ctrl]+Z</code>是变为后台暂停运行，<code>bg</code>是让后台暂停的进程变为运行状态。使用方法同fg</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">bg</span> %jobnumber<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="重启-删除后台进程kill"><a href="#重启-删除后台进程kill" class="headerlink" title="重启/删除后台进程kill"></a>重启/删除后台进程kill</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107134621042.png" alt="image-20220107134621042"></p>
<p>对于signal，主要了解1、9、15的用法。</p>
<p>另外，kill后面接的数字<strong>默认是PID</strong>，如果是bash的工作控制，则要使用<code>%jobnumber</code>形式。</p>
<h4 id="脱机管理"><a href="#脱机管理" class="headerlink" title="脱机管理"></a>脱机管理</h4><p>​    如果是远程ssh登录Linux，单单使用<code>&amp;</code>将进程后台运行，在会话结束时，进程也会关闭。需要使用<code>nohup</code>将进程放入系统后台，而不是bash后台</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107135342163.png" alt="image-20220107135342163"></p>
<p>注意，<strong>nohup并不支持bash内置命令，所以后面接的命令必须要是外部命令</strong>。</p>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="进程查看"><a href="#进程查看" class="headerlink" title="进程查看"></a>进程查看</h4><ul>
<li><p><strong>某一时间点</strong>系统进程查看ps</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107135940956.png" alt="image-20220107135940956"></p>
</li>
<li><p>仅查看自己的bash相关进程<code>ps -l</code></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107140029482.png" alt="image-20220107140029482"></p>
<ol>
<li>进程标志和权限说明<ul>
<li>4表示进程的权限为root</li>
<li>1表示此子进程仅可fork而无法实际执行(exec)</li>
</ul>
</li>
<li>进程的状态<ul>
<li>R表示进程正在运行中</li>
<li>S表示进程正在睡眠，可以被唤醒</li>
<li>D表示阻塞，通常可能在等待I/O</li>
<li>T表示停止状态</li>
<li>Z表示“僵尸”状态，进程已经终止，但却无法被删除至内存外</li>
</ul>
</li>
<li>进程被哪个UID拥有</li>
<li>进程的PID</li>
<li>进程的父进程PID（PPID）</li>
<li>CPU使用率，单位为百分比</li>
<li>PRI/NI和CPU，表示进程被CPU所执行的优先级。数值越小代表越快被CPU执行</li>
<li>ADDR/SZ/WCHAN，和内存有关<ul>
<li>ADDR是kernel function，指出该进程在内存的哪个部分，如果是running进程，会显示<code>-</code></li>
<li>SZ表示进程用掉多少内存</li>
<li>WCHAN表示目前进程是否在运行中，如果是running进程，会显示<code>-</code></li>
</ul>
</li>
<li>TTY表示登录者的终端机位置，若为远程登录则使用动态终端接口(pts/n)。</li>
<li>TIME表示进程实际花费CPU运行的时间</li>
<li>CMD，表示造成此程序的触发进程的命令为何</li>
</ol>
</li>
<li><p>查看系统所有进程<code>ps aux</code></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107142511658.png" alt="image-20220107142511658"></p>
<ol>
<li>USER，进程属于哪个用户账号</li>
<li>PID</li>
<li>%CPU，进程使用的CPU资源百分比</li>
<li>%MEM，进程所占用的物理内存百分比</li>
<li>VSZ，进程使用掉的虚拟内存量，单位KB</li>
<li>RSS，进程占用的固定的内存量，单位KB</li>
<li>TTY，进程的终端机位置，网络连接显示pts/n，和终端机无关则显示<code>?</code></li>
<li>STAT，进程状态，</li>
<li>START，进程被触发启动的时间</li>
<li>TIME，进程实际使用CPU的时间</li>
<li>COMMAND，进程的实际命令</li>
</ol>
</li>
<li><p>僵尸进程</p>
<ul>
<li><p>原因</p>
<p>该进程应该已经执行完毕，或是因故应该要终止了，但是该进程的父进程却无法完整将该进程结束，从而进程一直存在内存中</p>
</li>
<li><p><code>ps</code>相关命令查询时，在COMMAND后还有<code>&lt;defunct&gt;</code>字样，即表示为僵尸进程</p>
</li>
<li><p>处理僵尸进程一般需要杀掉其父进程，或者reboot</p>
</li>
</ul>
</li>
<li><p><strong>动态</strong>查看进程变化<code>top</code></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107143601079.png" alt="image-20220107143601079"></p>
</li>
<li><p>进程相关性查看<code>pstree</code></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107143831020.png" alt="image-20220107143831020"><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107143841556.png" alt="image-20220107143841556"></p>
<p>可以看出，<strong>所有进程都是依附在init进程下面。</strong></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107144454140.png" alt="image-20220107144454140"></p>
</li>
</ul>
<h4 id="进程重启、关闭、删除"><a href="#进程重启、关闭、删除" class="headerlink" title="进程重启、关闭、删除"></a>进程重启、关闭、删除</h4><p>依然使用前面说过的<code>kill</code>命令：<code>kill -signal PID</code></p>
<p>还可以使用<code>killall -signal command</code></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107145029150.png" alt="image-20220107145029150"><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107145039002.png" alt="image-20220107145039002"></p>
<p>场景的<code>signal</code>如下：</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107144728687.png" alt="image-20220107144728687"></p>
<h3 id="进程的执行顺序"><a href="#进程的执行顺序" class="headerlink" title="进程的执行顺序"></a>进程的执行顺序</h3><p>​    CPU具体执行哪个进程需要考虑进程的优先执行序(Priority)和CPU调度</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107145552380.png" alt="image-20220107145552380"></p>
<ul>
<li><p>进程的PRI和NI</p>
<p>进程的PRI即为优先级的意思，该值越低，越优先执行。</p>
<p>但是<strong>PRI由内核动态调整，用户无法直接调整PRI值</strong>，所以通过NI（nice）值来调整。最终的CPU执行优先级为：</p>
<pre class="line-numbers language-none"><code class="language-none">PRI(final) &#x3D; PRI(kernel) + nice<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>nice的值可调范围为<code>-20~19</code></p>
<ul>
<li>root可以调整其他人的nice值</li>
<li>一般用户仅可以调整自己的nice，且范围为<code>0~19</code></li>
<li>一般用户仅可以把nice值增大</li>
<li><strong>nice值可以在子父进程之前传递</strong></li>
</ul>
</li>
<li><p>设置程序初始nice值</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107150142119.png" alt="image-20220107150142119"></p>
</li>
<li><p>调整进程nice值</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107150226734.png" alt="image-20220107150226734"></p>
</li>
</ul>
<h3 id="特殊文件与程序"><a href="#特殊文件与程序" class="headerlink" title="特殊文件与程序"></a>特殊文件与程序</h3><h4 id="具有SUID-SGID权限的命令执行状态"><a href="#具有SUID-SGID权限的命令执行状态" class="headerlink" title="具有SUID/SGID权限的命令执行状态"></a>具有SUID/SGID权限的命令执行状态</h4><p>SUID的权限会生效是由于具有该权限的程序被触发</p>
<p>比如passwd执行后，就具有root的权限。触发passwd后，会取得一个新的进程与PID，该PID产生时通过SUID来给予该PID特殊的权限设置。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107152830305.png" alt="image-20220107152830305"></p>
<h4 id="proc-目录的意义"><a href="#proc-目录的意义" class="headerlink" title="/proc/*目录的意义"></a><code>/proc/*</code>目录的意义</h4><p>所有的进程存在内存中，内存中的数据又是写入到<code>/proc/*</code>目录下。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107153425758.png" alt="image-20220107153425758"></p>
<h4 id="查找正在使用某文件的程序fuser"><a href="#查找正在使用某文件的程序fuser" class="headerlink" title="查找正在使用某文件的程序fuser"></a>查找正在使用某文件的程序fuser</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107153550031.png" alt="image-20220107153550031"></p>
<h4 id="列出被进程所打开的文件名lsof"><a href="#列出被进程所打开的文件名lsof" class="headerlink" title="列出被进程所打开的文件名lsof"></a>列出被进程所打开的文件名lsof</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107153702734.png" alt="image-20220107153702734"></p>
<h4 id="找到正在执行的进程的PID"><a href="#找到正在执行的进程的PID" class="headerlink" title="找到正在执行的进程的PID"></a>找到正在执行的进程的PID</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107153753496.png" alt="image-20220107153753496"></p>
<h2 id="系统资源管理"><a href="#系统资源管理" class="headerlink" title="系统资源管理"></a>系统资源管理</h2><h3 id="查看内存使用情况free"><a href="#查看内存使用情况free" class="headerlink" title="查看内存使用情况free"></a>查看内存使用情况free</h3><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107151350735.png" alt="image-20220107151350735"></p>
<h3 id="查看内核相关信息uname"><a href="#查看内核相关信息uname" class="headerlink" title="查看内核相关信息uname"></a>查看内核相关信息uname</h3><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107151432730.png"></p>
<h3 id="查看系统启动时间和负载uptime"><a href="#查看系统启动时间和负载uptime" class="headerlink" title="查看系统启动时间和负载uptime"></a>查看系统启动时间和负载uptime</h3><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107151542516.png" alt="image-20220107151542516"></p>
<h3 id="跟踪网络netstat"><a href="#跟踪网络netstat" class="headerlink" title="跟踪网络netstat"></a>跟踪网络netstat</h3><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107151704286.png" alt="image-20220107151704286"></p>
<p>比较常用的有，查看哪些进程启动了网络连接/占用网络端口</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107151859230.png" alt="image-20220107151859230"></p>
<h3 id="分析内核产生的信息dmesg"><a href="#分析内核产生的信息dmesg" class="headerlink" title="分析内核产生的信息dmesg"></a>分析内核产生的信息dmesg</h3><p>特别是开机检测硬件的一些信息等。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">dmesg</span> <span class="token operator">|</span> <span class="token function">more</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="检测系统资源变化vmstat"><a href="#检测系统资源变化vmstat" class="headerlink" title="检测系统资源变化vmstat"></a>检测系统资源变化vmstat</h3><p>可以检测CPU/内存/磁盘输入输出状态等</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107152254151.png" alt="image-20220107152254151"><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107152308103.png" alt="image-20220107152308103"></p>
<h2 id="SELinux"><a href="#SELinux" class="headerlink" title="SELinux"></a>SELinux</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>​    Security Enhanced Linux之意，是在进行程序、文件等权限设置依据的一个内核模板。由于网路服务也是程序，刚好也能够控制网络服务能否访问系统资源。</p>
<p>​    依据进程的所有者与文件资源的<code>rwx</code>权限来决定有无访问文件系统能力的方式，被称为“自主访问控制”（Discretionary Access Control，DAC）。在某些情况会有问题，如root具有最高的权限、用户可以取得进程来更改文件资源的访问权限等</p>
<p>​    为了避免上述问题发生，SELinux导入强制访问控制（Mandatory Access Control，MAC）的方式。可以<strong>针对特定的进程与特定的文件资源来进行权限的控制。将权限控制的主体，从用户变成 了进程</strong>。</p>
<h3 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h3><p>​    SELinux的目标是：该进程能否读取文件资源</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107160035341.png" alt="image-20220107160035341"></p>
<ul>
<li><p>主体</p>
<p>SELinux主要想管理的就是进程</p>
</li>
<li><p>目标</p>
<p>SELinux想访问的是文件系统</p>
</li>
<li><p>策略</p>
<p>SELinux会依据某些服务来制定基本的访问安全性策略。主要有两个：</p>
<ul>
<li>targeted：针对网络服务限制较多，针对本机限制较少。是默认策略</li>
<li>strict：完整的SELinux限制，限制方面较为严格</li>
</ul>
</li>
<li><p>安全上下文</p>
<p>主体与目标的安全上下文必须一致才能顺利访问。</p>
<p>安全上下文有点类似<code>rwx</code>。进程的安全上下文存在内存中，文件的安全上下文放置到文件的inode内。</p>
<p>进程的安全上下文使用<code>ps -Z</code>查看，文件的安全上下文使用<code>ls -Z</code>查看：</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220107160341505.png" alt="image-20220107160341505"></p>
<p>以<code>:</code>隔开为3个字段</p>
<ol>
<li><p>身份标识(user)</p>
<ul>
<li>root，标识root的账号身份</li>
<li>system_u，标识系统程序，通常就是进程</li>
<li>user_u，标识一般用户账号的身份</li>
</ul>
</li>
<li><p>角色(role)</p>
<p>表明这个数据是程序、文件资源还是用户</p>
<ul>
<li>object_r：代表文件或目录等文件资源</li>
<li>system_r：进程，一般用户</li>
</ul>
</li>
<li><p>类型(type)</p>
<p>在文件资源上称为type，在进程上称为domain。</p>
<p><strong>主体与目标之间是否具有可以读写的权限与进程的domain及文件的type有关</strong>。</p>
<blockquote>
<p>如httpd_exec_t的domain，可以访问httpd_sys_content_t这个type的文件</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h3 id="SELinux启动、关闭和查看"><a href="#SELinux启动、关闭和查看" class="headerlink" title="SELinux启动、关闭和查看"></a>SELinux启动、关闭和查看</h3><h4 id="SELinux查看"><a href="#SELinux查看" class="headerlink" title="SELinux查看"></a>SELinux查看</h4><ul>
<li><p>查看运行状态</p>
<p>并不是所有的Linux distribution都支持SELinux。SELinux支持三种（状态）模式：</p>
<ul>
<li>enforcing，强制模式，代表SELinux正在运行，且已经正确开始限制domain/type</li>
<li>permissive，宽容模式，点SELinux正在运行，不过仅会有警告信息并不会实际限制domain/type的访问。**这种模式可以用来作为SELinux的调试</li>
<li>disabled，关闭状态，SELinux没有运行</li>
</ul>
<p>使用<code>getenforce</code>进行SELinux状态查看</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110124621230.png" alt="image-20220110124621230"></p>
</li>
<li><p>查看策略等信息</p>
<p>使用<code>sestatus</code>进行SELinux状态查看。</p>
<p><strong>SELinux的配置文件是<code>/etc/selinux/config</code></strong></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110125019761.png" alt="image-20220110125019761"></p>
<p>效果如图：</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110125038013.png" alt="image-20220110125038013"></p>
</li>
</ul>
<h4 id="SELinux启动与关闭"><a href="#SELinux启动与关闭" class="headerlink" title="SELinux启动与关闭"></a>SELinux启动与关闭</h4><ul>
<li><p>SELinux的运行状态、策略等更改时，需要重新启动SELinux</p>
</li>
<li><p>启动SELinux，需要编辑配置文件<code>/etc/selinux/config</code></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110163820510.png" alt="image-20220110163820510"></p>
<p>配置完后，在内核文件查询是否已经开启。<strong>如果要开启SELinux，不可以在kernel行出现selinux=0的字样。</strong></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110164047471.png" alt="image-20220110164047471"></p>
</li>
<li><p>SELinux模式在enforcing和permissive之间切换<code>setenforce</code></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110164317413.png" alt="image-20220110164317413"></p>
<p>注意，<code>setenforce</code>无法在Disabled模式下面进行切换。</p>
</li>
</ul>
<h3 id="安全上下文的设置和查看"><a href="#安全上下文的设置和查看" class="headerlink" title="安全上下文的设置和查看"></a>安全上下文的设置和查看</h3><p>安全上下文的配置文件目录是<code>/etc/selinux/targeted/</code></p>
<h4 id="安全上下文的查看"><a href="#安全上下文的查看" class="headerlink" title="安全上下文的查看"></a>安全上下文的查看</h4><ul>
<li><p>进程的安全上下文使用<code>ps -Z</code>查看</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110165137536.png" alt="image-20220110165137536"></p>
</li>
<li><p>文件的安全上下文使用<code>ls -Z</code>查看</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110165153206.png" alt="image-20220110165153206"></p>
</li>
</ul>
<p>httpd这个进程拥有的httpd_t这个domain去读取index.html文件时，就会看是否和文件的type匹配。</p>
<h4 id="修改文件的安全上下文chcon"><a href="#修改文件的安全上下文chcon" class="headerlink" title="修改文件的安全上下文chcon"></a>修改文件的安全上下文<code>chcon</code></h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110165330344.png" alt="image-20220110165330344"></p>
<h4 id="文件的默认安全上下文的查询与修改semanage"><a href="#文件的默认安全上下文的查询与修改semanage" class="headerlink" title="文件的默认安全上下文的查询与修改semanage"></a>文件的默认安全上下文的查询与修改<code>semanage</code></h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110172110502.png" alt="image-20220110172110502"></p>
<h4 id="文件的安全上下文恢复默认值restorecon"><a href="#文件的安全上下文恢复默认值restorecon" class="headerlink" title="文件的安全上下文恢复默认值restorecon"></a>文件的安全上下文恢复默认值<code>restorecon</code></h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110165413096.png" alt="image-20220110165413096"></p>
<h3 id="SELinux的策略与规则管理"><a href="#SELinux的策略与规则管理" class="headerlink" title="SELinux的策略与规则管理"></a>SELinux的策略与规则管理</h3><p>策略相关的配置文件目录是<code>/etc/selinux/targeted/</code></p>
<h4 id="策略详细信息查询seinfo"><a href="#策略详细信息查询seinfo" class="headerlink" title="策略详细信息查询seinfo"></a>策略详细信息查询seinfo</h4><p>策略的信息包括：<strong>所有类型</strong>、<strong>所有角色</strong>、<strong>所有身份标识</strong>、<strong>所有规则（布尔值）</strong>。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110170352796.png" alt="image-20220110170352796"></p>
<h4 id="详细规则（布尔值）查询sesearch"><a href="#详细规则（布尔值）查询sesearch" class="headerlink" title="详细规则（布尔值）查询sesearch"></a>详细规则（布尔值）查询sesearch</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110171422652.png" alt="image-20220110171422652"></p>
<h4 id="布尔值状态查询getsebool"><a href="#布尔值状态查询getsebool" class="headerlink" title="布尔值状态查询getsebool"></a>布尔值状态查询getsebool</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110171749959.png" alt="image-20220110171749959"></p>
<h4 id="布尔值关闭或开启setsebool"><a href="#布尔值关闭或开启setsebool" class="headerlink" title="布尔值关闭或开启setsebool"></a>布尔值关闭或开启setsebool</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110171825521.png" alt="image-20220110171825521"></p>
<h3 id="SELinux的输出信息"><a href="#SELinux的输出信息" class="headerlink" title="SELinux的输出信息"></a>SELinux的输出信息</h3><p>SELinux在发生错误时，有几个服务会记录这些信息</p>
<ul>
<li><p><code>setroubleshoot</code>，将错误信息写入<code>/var/log/messages</code></p>
<p>设置服务开启：</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110165755103.png" alt="image-20220110165755103"></p>
<p>发生错误时，可以查看：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">cat</span> /var/log/messages <span class="token operator">|</span> <span class="token function">grep</span> setroubleshoot<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p><code>audit</code>，将详细数据写入<code>/var/log/audit/audit.log</code></p>
<p>与<code>setroubleshoot</code>不同的是，<code>auditd</code>会将所有信息记录下来，不仅仅是错误信息。</p>
<p>设置服务开启：</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110170059951.png" alt="image-20220110170059951"><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110170108678.png" alt="image-20220110170108678"></p>
<p>可以使用<code>audit2why</code>进行文件数据分析</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110170211945.png" alt="image-20220110170211945"></p>
</li>
</ul>
<h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>​    常驻在内存当中的进程都负责一些系统所提供的功能以服务用户各项任务，因此这些常驻进程就会被称为服务(service)。执行service的程序或进程称之为<strong>daemon</strong>。</p>
<h4 id="服务的分类"><a href="#服务的分类" class="headerlink" title="服务的分类"></a>服务的分类</h4><p><strong>按照daemon启动与管理的方式分：</strong></p>
<ul>
<li><p>stand_alone，可自行单独启动服务</p>
<p>自行启动，不必通过其他机制的管理</p>
<p>值存在内存中，响应速度较快</p>
</li>
<li><p>super_daemon，通过这个特殊的daemon统一管理其他服务</p>
<p>当没有客户端的请求时，各项服务都未启动，等到有请求时，super daemon才唤醒相对应的服务。当请求结束后，服务也会关闭并释放系统资源。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110173218216.png" alt="image-20220110173218216"></p>
<p>有两种具体的工作状态：</p>
<ul>
<li><p>多线程</p>
<p>super deamon同时负责多个进程</p>
</li>
<li><p>单线程</p>
<p>super deamon一个一个处理请求</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110173450041.png" alt="image-20220110173450041"></p>
</li>
</ul>
<p>​    </p>
<p><strong>按照daemon工作状态的方式分：</strong></p>
<ul>
<li><p>signal-control</p>
<p>通过信号来管理，有请求进来会立即启动去处理</p>
</li>
<li><p>interval-control</p>
<p>每个一段时间主动执行某项工作。</p>
</li>
</ul>
<h4 id="daemon的命令规则"><a href="#daemon的命令规则" class="headerlink" title="daemon的命令规则"></a>daemon的命令规则</h4><p>服务名称后，通常会加一个<code>d</code>，{xxx}d。</p>
<h3 id="服务的端口号"><a href="#服务的端口号" class="headerlink" title="服务的端口号"></a>服务的端口号</h3><p>在配置文件**/etc/services**中，写了服务与端口号的对应关系。格式为：</p>
<p><code>&lt;daemon name&gt; &lt;port/数据包协议&gt; &lt;服务的说明&gt;</code></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110173927162.png" alt="image-20220110173927162"></p>
<h3 id="服务的启动"><a href="#服务的启动" class="headerlink" title="服务的启动"></a>服务的启动</h3><h4 id="服务的脚本文件"><a href="#服务的脚本文件" class="headerlink" title="服务的脚本文件"></a>服务的脚本文件</h4><p>Linux distribution提供了服务的shell script文件来就进行启动和配置。</p>
<ul>
<li><code>/etc/init.d/*</code>，启动脚本放置处</li>
<li><code>/etc/sysconfig/*</code>，服务的初始化环境配置文件</li>
<li><code>/etc/xinetd.conf, /etc/xinetd.d/*</code>，super daemon配置文件</li>
<li><code>/etc/*</code>，各服务的配置文件</li>
<li><code>/var/lib/*</code>，各服务产生的数据库</li>
<li><code>/var/run/*</code>，各服务的程序PID记录处</li>
</ul>
<h4 id="Stand-alnoe的-etc-init-d-的启动"><a href="#Stand-alnoe的-etc-init-d-的启动" class="headerlink" title="Stand_alnoe的/etc/init.d/*的启动"></a>Stand_alnoe的/etc/init.d/*的启动</h4><ul>
<li><p><code>/etc/init.d/*</code>下文件名直接启动</p>
</li>
<li><p><code>service</code>命令启动</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110174804482.png" alt="image-20220110174804482"></p>
<p>service分析daemon后的参数，再去<code>/etc/init.d/*</code>取正确的服务来执行</p>
</li>
</ul>
<h4 id="由Super-daemon管理的启动"><a href="#由Super-daemon管理的启动" class="headerlink" title="由Super_daemon管理的启动"></a>由Super_daemon管理的启动</h4><p>​    <strong>super_daemon是由<code>xinetd</code>这个进程实现的</strong>，它管理的服务的配置文件在<code>/etc/xinetd.d/*</code>下面，通过编辑服务文件的<code>disable</code>字段来启动。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token assign-left variable">disable</span><span class="token operator">=</span>yes <span class="token comment">#关闭服务</span>
<span class="token assign-left variable">disable</span><span class="token operator">=</span>no  <span class="token comment">#开启服务</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>​    **xinetd管理的服务，有个默认的配置文件<code>xinetd.conf</code>**。当启动的服务，没有设置配置文件里面的值时，则该配置文件的值就作为默认值。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110175640107.png" alt="image-20220110175640107"></p>
<h4 id="设置开启立即启动服务"><a href="#设置开启立即启动服务" class="headerlink" title="设置开启立即启动服务"></a>设置开启立即启动服务</h4><ul>
<li><p>管理系统服务默认开启开启启动chkconfig</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110181651492.png" alt="image-20220110181651492"></p>
</li>
<li><p>图形界面管理模式ntsysv</p>
<p>Red Hat系统独有，通过图像界面管理服务</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110181743827.png" alt="image-20220110181743827"></p>
</li>
</ul>
<h4 id="自定义服务"><a href="#自定义服务" class="headerlink" title="自定义服务"></a>自定义服务</h4><p>定义好shell script文件后，放入<code>/etc/init.d/</code>下面。文件有些格式要求：</p>
<p><code>chkconfig:[runlevels][启动顺序][停止顺序]</code></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110182231354.png" alt="image-20220110182231354"></p>
<p>然后还是使用<code>chkconfig</code>。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110181931860.png" alt="image-20220110181931860"></p>
<h3 id="服务的查看"><a href="#服务的查看" class="headerlink" title="服务的查看"></a>服务的查看</h3><p>​    前面在<code>Linux进程-系统资源管理-跟踪网络netstat</code>已经介绍过。查看端口即可查看相关服务。</p>
<h3 id="服务的防火墙管理"><a href="#服务的防火墙管理" class="headerlink" title="服务的防火墙管理"></a>服务的防火墙管理</h3><p>​    防火墙，是针对源IP或域进行允许或拒绝的设置，以决定该连接是否能够成功实现连接的一种方式。</p>
<p>​    <strong>任何以xinetd管理的服务都可以通过<code>/etc/hosts.allow和/etc/hosts.deny</code>来设置防火墙</strong>。通过TCP数据包分析出IP和Port（TCP Wrappers）并搭配这两个文件，就能决定连接是否可以进入主机。<strong>服务必须支持TCP Wrappers的功能，才能受这两个配置文件的限制</strong>。</p>
<ul>
<li><p>查询程序是否支持TCP Wrappers</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ldd $ <span class="token punctuation">(</span>which service1 service2 <span class="token punctuation">..</span>.<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>若有<code>libwrap.so</code>这个函数库文件，即支持TCP Wrappers.</p>
</li>
<li><p>配置文件语法</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110180554365.png" alt="image-20220110180554365"></p>
</li>
<li><p>hosts.allow的优先级高于host.deny</p>
</li>
<li><p>配置文件第一和第二字段的特殊符号：</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220110180741836.png" alt="image-20220110180741836"></p>
</li>
<li><p>可以配合TCP Wrappers软件，配置文件做更复杂的操作</p>
</li>
</ul>
<h1 id="Linux应用程序"><a href="#Linux应用程序" class="headerlink" title="Linux应用程序"></a>Linux应用程序</h1><ul>
<li><p>源码</p>
<p>Linux的软件几乎都是经过GPL的授权，所以每个软件几乎均提供源代码。</p>
<p>由于有些源码文件较大，所以一般软件的源码都是打包和压缩为Tarball文件，扩展名一般为<code>*.tar.gzip</code>或<code>*.tar.bz2</code>。里面的文件通常包含：</p>
<ul>
<li>源代码文件</li>
<li>检测程序文件，可能为configure或config等文件名</li>
<li>本软件的建议说明与安装说明，INSTALL或README</li>
</ul>
</li>
<li><p>Linux的软件</p>
<p>软件的命名也有一定的规范：</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220111152129217.png" alt="image-20220111152129217"></p>
<p>软件的安装和升级主要有两种模式：</p>
<ul>
<li>Red Hat系统（含Fedora/CentOs系列）开发的RPM软件管理机制与yum在线更新模式</li>
<li>Debian使用的dpkg软件管理机制与APT在线更新模式等</li>
</ul>
</li>
</ul>
<h2 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h2><p>全名是RedHat Package Manager，有如下<strong>优点</strong>：</p>
<ul>
<li>RPM内含已经编译过的程序与设置文件等数据，可以让用户免除重新编译的困扰</li>
<li>RPM在被安装之前，会先检查系统的硬盘容量、操作系统版本等，可避免文件被错误安装</li>
<li>RPM文件本身提供软件版本信息、依赖属性软件名称、软件用途说明、软件所含文件等信息，便于了解软件</li>
<li>RPM管理的方式使用<strong>数据库记录PRM文件的相关参数</strong>，便于升级、删除、查询与验证。</li>
</ul>
<h3 id="软件默认安装路径"><a href="#软件默认安装路径" class="headerlink" title="软件默认安装路径"></a>软件默认安装路径</h3><ul>
<li><p>安装软件完毕后，软件相关信息被写入<code>/var/lib/rpm/</code>目录下的数据库文件中</p>
</li>
<li><p>软件内的文件的位置：</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220111152654789.png" alt="image-20220111152654789"></p>
<p>一般情况：如果是应用软件：<code>/usr/local</code>；如果是系统相关：<code>/usr/sbin</code>,<code>/usr/bin</code>等。具体可以使用<code>rpm -ql softwarename</code>查看。</p>
</li>
</ul>
<h3 id="RPM安装软件"><a href="#RPM安装软件" class="headerlink" title="RPM安装软件"></a>RPM安装软件</h3><p>安装软件必须先取得<strong>root权限</strong>。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220111152831791.png" alt="image-20220111152831791"></p>
<p>其他的参数：</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220111152942318.png" alt="image-20220111152942318"></p>
<h3 id="RPM升级与更新"><a href="#RPM升级与更新" class="headerlink" title="RPM升级与更新"></a>RPM升级与更新</h3><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220111153209580.png" alt="image-20220111153209580"></p>
<p><strong>不过一般是使用yum来进行软件的升级更新</strong>。</p>
<h3 id="RPM软件查询"><a href="#RPM软件查询" class="headerlink" title="RPM软件查询"></a>RPM软件查询</h3><p>查询使用RPM安装的软件的信息。</p>
<p>本质是去查询<code>/var/lib/rpm/</code>目录下的数据库文件。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220111153252618.png" alt="image-20220111153252618"></p>
<h3 id="RPM卸载软件与重建数据库"><a href="#RPM卸载软件与重建数据库" class="headerlink" title="RPM卸载软件与重建数据库"></a>RPM卸载软件与重建数据库</h3><p>卸载的时候，很容易发送软件依赖属性导致无法删除的情况。所以删除的时候一定要从<strong>最上往下删除</strong>。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">rpm</span> -e softwarename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在RPM安装、删除、升级等过程中，可能会破坏<code>/var/lib/rpm/</code>目录下的数据库文件。可以进行数据库重建：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">rpm</span> --rebuilddb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="YUM"><a href="#YUM" class="headerlink" title="YUM"></a>YUM</h2><p>​    yum是通过分析RPM的标题数据后，根据各软件的相关性制作出属性依赖时的解决方案，然后可以自动处理软件的依赖属性问题，以解决软件安装或删除与升级问题。</p>
<h3 id="yum的查询软件"><a href="#yum的查询软件" class="headerlink" title="yum的查询软件"></a>yum的查询软件</h3><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220111154027037.png" alt="image-20220111154027037"></p>
<h3 id="yum安装和升级软件"><a href="#yum安装和升级软件" class="headerlink" title="yum安装和升级软件"></a>yum安装和升级软件</h3><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220111154109937.png" alt="image-20220111154109937"></p>
<h3 id="yum删除软件"><a href="#yum删除软件" class="headerlink" title="yum删除软件"></a>yum删除软件</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">yum remove softwarename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="yum的配置文件"><a href="#yum的配置文件" class="headerlink" title="yum的配置文件"></a>yum的配置文件</h3><h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><h2 id="程序编辑器"><a href="#程序编辑器" class="headerlink" title="程序编辑器"></a>程序编辑器</h2><h3 id="Vi"><a href="#Vi" class="headerlink" title="Vi"></a>Vi</h3><p>​    所以UNIX Like系统都会内置<code>Vi</code>文本编辑器，很多软件等编辑接口也都会主动调用<code>vi</code>。</p>
<h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><p>​    分为一般模式、编辑模式与命令模式三种。</p>
<ul>
<li><p>一般模式</p>
<p>以<code>vi</code>命令打开一个文件就直接进入一般模式了。</p>
<p>可以进行删除、复制、粘贴等操作（<strong>但不会改变文件内容</strong>）</p>
</li>
<li><p>编辑模式</p>
<p>在一般模式，按下<code>i, I, o, O, a, A, r, R</code>按键进入，可以编辑文件内容。</p>
</li>
<li><p>命令行模式</p>
<p>在一般模式，输入<code>:</code>、<code>/</code>、<code>?</code>，光标移动到最下面一行，输入相关参数可以进行查找数据等操作。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220103111542246.png" alt="image-20220103111542246"></p>
<h4 id="按键说明"><a href="#按键说明" class="headerlink" title="按键说明"></a>按键说明</h4><ul>
<li>移动光标</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220103111659552.png" alt="image-20220103111659552"></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220103112214806.png" alt="image-20220103112214806"></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220103111753039.png" alt="image-20220103111753039"></p>
<ul>
<li><p>一般模式切换编辑模式</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220103112427307.png" alt="image-20220103112427307"></p>
</li>
<li><p>一般模式切换到命令行模式</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220103112503104.png" alt="image-20220103112503104"></p>
</li>
</ul>
<h3 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h3><h4 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h4><p>​    <code>Vim</code>是<code>Vi</code>的高级版本，<code>Vim</code>可以使用颜色或底线等方式来显示一些特殊的信息，还支持正则表达式的查找架构、多文件编辑、块复制等。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220103113750337.png" alt="image-20220103113750337"></p>
<h4 id="块选择"><a href="#块选择" class="headerlink" title="块选择"></a>块选择</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220103113153738.png" alt="image-20220103113153738"></p>
<ol>
<li>使用<code>vim</code>打开文件</li>
<li>使用按键移动光标到预选块左上角</li>
<li>按下<code>[Ctrl] + V</code>后将光标移动到预选块右下角</li>
<li>按下<code>y</code>进行复制</li>
<li>按下<code>p</code>进行粘贴</li>
</ol>
<h4 id="多文件编辑"><a href="#多文件编辑" class="headerlink" title="多文件编辑"></a>多文件编辑</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220103113454143.png"></p>
<h4 id="多窗口"><a href="#多窗口" class="headerlink" title="多窗口"></a>多窗口</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220103113619794.png" alt="image-20220103113619794"></p>
<h2 id="Shell概念"><a href="#Shell概念" class="headerlink" title="Shell概念"></a>Shell概念</h2><h3 id="硬件、内核与Shell"><a href="#硬件、内核与Shell" class="headerlink" title="硬件、内核与Shell"></a>硬件、内核与Shell</h3><p>​    我们必须通过<code>shell</code>将我们输入到命令与内核通信，好让内核可以控制硬件来正确无误的工作。</p>
<p>​    <code>Shell</code>的功能只是提供用户操作系统的一个接口，因此<code>Shell</code>需要可以调用其他软件。即<strong>只要能操作应用程序等接口都能称为<code>shell</code></strong>.</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220103114029649.png" alt="image-20220103114029649"></p>
<h3 id="Linux的Shell"><a href="#Linux的Shell" class="headerlink" title="Linux的Shell"></a>Linux的Shell</h3><p>​    在<code>/etc/shells</code>文件中定义了可用的<code>shell</code>。</p>
<ul>
<li><code>/bin/sh</code>，<strong>已经被<code>/bin/bash</code>所代替</strong></li>
<li><code>/bin/bash</code>，Linux的模式shell，基于GNU架构</li>
<li><code>/bin/ksh</code>，Kornshell由AT&amp;T Bell lab.发展出来，兼容bash</li>
<li><code>/bin/tcsh</code>，整合C Sehll，提供更多功能</li>
<li><code>/bin/csh</code>，已经被/bin/tcsh`所替代</li>
<li><code>/bin/zsh</code>，基于ksh发展出来，功能更强大的shell</li>
</ul>
<p><code>bash</code>内置了很多命令，可以利用<code>type</code>判断是否是内置命令。</p>
<h2 id="Shell变量"><a href="#Shell变量" class="headerlink" title="Shell变量"></a>Shell变量</h2><p>​    程序、变量与不同用户的关系：</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220103163456519.png" alt="image-20220103163456519"></p>
<p><strong>注意，后面命令别名、自定义的变量，如果没有进行保存操作（Bash Shell小节会说），在注销bash后会失效</strong>。</p>
<h3 id="变量的显示与设置"><a href="#变量的显示与设置" class="headerlink" title="变量的显示与设置"></a>变量的显示与设置</h3><ul>
<li><p>显示</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">echo</span> <span class="token variable">$&#123;var&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>设置</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token assign-left variable">var</span><span class="token operator">=</span>value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>注意：</p>
<ul>
<li><p>等号两边不能接空格</p>
</li>
<li><p>变量内容有空格，可以使用双引号或单引号</p>
</li>
<li><p><strong>若变量需要在其他子进程执行，需要使用<code>export</code>命令</strong></p>
<p>子进程仅会继承父进程的环境变量，子进程不会继承父进程的自定义变量</p>
<p><code>export</code>即是将自定义变量转换为环境变量</p>
</li>
<li><p>通常大小自负为系统默认变量，自行设置变量可以使用小写字符</p>
</li>
<li><p>设置数字变量</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">var<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">=</span>content
<span class="token comment">#数组名字为var，下标为index，内容为content</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>取消设置</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">unset</span> varname<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><h4 id="evn命令查看环境变量"><a href="#evn命令查看环境变量" class="headerlink" title="evn命令查看环境变量"></a><code>evn</code>命令查看环境变量</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105133804168.png" alt="image-20220105133804168"></p>
<h4 id="set命令查看所有变量"><a href="#set命令查看所有变量" class="headerlink" title="set命令查看所有变量"></a><code>set</code>命令查看所有变量</h4><p>​    含环境变量与自定义变量</p>
<p>​    <code>export</code>即是将自定义变量转换为环境变量</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105133904835.png" alt="image-20220105133904835"></p>
<h3 id="变量相关操作命令"><a href="#变量相关操作命令" class="headerlink" title="变量相关操作命令"></a>变量相关操作命令</h3><h4 id="语系变量locale"><a href="#语系变量locale" class="headerlink" title="语系变量locale"></a>语系变量locale</h4><ul>
<li><p>查看系统支持的所有语系</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">locale -a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>查看语系相关设置编码</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">locale<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220103170213177.png" alt="image-20220103170213177"></p>
</li>
</ul>
<h4 id="读取键盘输入的变量read"><a href="#读取键盘输入的变量read" class="headerlink" title="读取键盘输入的变量read"></a>读取键盘输入的变量read</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220103170543499.png" alt="image-20220103170543499"></p>
<h4 id="声明变量类型declare"><a href="#声明变量类型declare" class="headerlink" title="声明变量类型declare"></a>声明变量类型declare</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220103171756248.png" alt="image-20220103171756248"></p>
<p>设置字符串时，默认变量类型为<strong>字符串</strong>。</p>
<h4 id="变量的删除、替换"><a href="#变量的删除、替换" class="headerlink" title="变量的删除、替换"></a>变量的删除、替换</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220103172941732.png" alt="image-20220103172941732"></p>
<h4 id="变量的测试与内容替换"><a href="#变量的测试与内容替换" class="headerlink" title="变量的测试与内容替换"></a>变量的测试与内容替换</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220103173042243.png" alt="image-20220103173042243"></p>
<h3 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h3><ul>
<li><p>设置别名</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">alias</span> <span class="token assign-left variable">newName</span><span class="token operator">=</span>originName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>查看别名</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">alias</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>删除别名</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">unalias</span> aliasName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<h2 id="Bash环境和操作"><a href="#Bash环境和操作" class="headerlink" title="Bash环境和操作"></a>Bash环境和操作</h2><h3 id="路径与命令查找顺序"><a href="#路径与命令查找顺序" class="headerlink" title="路径与命令查找顺序"></a>路径与命令查找顺序</h3><p>​    当同一个命令名对应不同文件时，查找顺序如下：</p>
<ol>
<li>以相对/绝对路径执行命令</li>
<li>由alias找到该命令执行</li>
<li>由bash内置的命令来执行</li>
<li>通过PATH环境变量的路径找到的一个命令来执行</li>
</ol>
<h3 id="登录和欢迎信息"><a href="#登录和欢迎信息" class="headerlink" title="登录和欢迎信息"></a>登录和欢迎信息</h3><ul>
<li><p>登录提示信息文件</p>
<ul>
<li><p><code>/etc/issue</code>放置本地登录信息</p>
<p>这个文件可以使用反斜杠作为变量调用。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105135332090.png" alt="image-20220105135332090"></p>
</li>
<li><p><code>/etc/issue.net</code>放置远程登录信息</p>
</li>
</ul>
</li>
<li><p>欢迎信息</p>
<p>登录完成后，告诉登录者的信息。在<code>/etc/motd</code>文件放置。</p>
</li>
</ul>
<h3 id="环境配置文件"><a href="#环境配置文件" class="headerlink" title="环境配置文件"></a>环境配置文件</h3><p>bash Shell有两种登录方式</p>
<ul>
<li><p>login shell</p>
<p>取得bash时需要完整的登录流程的，即为login shell。</p>
<p>这种方式登录时会读取<code>/etc/profile</code>和<code>~/.bash_profile或~/bash_login或~/.profile</code>。前者为系统整体设置，后者为用户个人设置。</p>
</li>
<li><p>non-login shell</p>
<p>取得bash接口的方法不需要重复登录时，如在图形界面登录后启动终端机，此时终端机的环境即为non-login shell。bash下产生的bash子进程也是这个情况</p>
</li>
</ul>
<h4 id="login-Shell"><a href="#login-Shell" class="headerlink" title="login Shell"></a>login Shell</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105141733209.png" alt="image-20220105141733209"></p>
<h5 id="系统配置文件"><a href="#系统配置文件" class="headerlink" title="系统配置文件"></a>系统配置文件</h5><p>​    <code>/etc/profile</code>每个用户登录后取得bash时一定要读取的文件。下面是这个文件中主要的几个变量：</p>
<ul>
<li>PATH：会依据UID决定PATH变量要不要含有sbin的系统命令目录</li>
<li>MAIL：依据账号设置好用户的mailbox到<code>/var/spool/mail/账号名</code></li>
<li>USER：根据用户的账号设置此变量内容</li>
<li>HOSTNAME：依据主机的hostname命令决定此变量内容</li>
<li>HISTSIZE：历史命令记录条数</li>
</ul>
<p>此外，文件中还会调用其他的配置文件。</p>
<h5 id="个人配置文件"><a href="#个人配置文件" class="headerlink" title="个人配置文件"></a>个人配置文件</h5><p>​    在读取<code>/etc/profile</code>后会继续读取个人配置文件。3个个人配置文件<strong>只会读取其中一个</strong>，读取顺序是：</p>
<ol>
<li><code>~/.bash_profile</code></li>
<li><code>~/.bash_login</code></li>
<li><code>~/.profile</code></li>
</ol>
<p>其中<code>~/.bash_profile</code>中主要逻辑是判断<code>~/.bashrc</code>文件是否存在，存在就读取。</p>
<h4 id="non-login-Shell"><a href="#non-login-Shell" class="headerlink" title="non-login Shell"></a>non-login Shell</h4><p>​    该方式登录bash仅会读取<code>~/.bashrc</code>而已。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105143606285.png" alt="image-20220105143606285"></p>
<h4 id="读取环境配置文件"><a href="#读取环境配置文件" class="headerlink" title="读取环境配置文件"></a>读取环境配置文件</h4><p>​    修改上述配置文件后，通常需要注销和重新登录后生效。但是使用<code>source</code>命令可以直接生效而不用重启.</p>
<pre class="line-numbers language-shel" data-language="shel"><code class="language-shel">source filename
. filename<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="通配符和特殊符号"><a href="#通配符和特殊符号" class="headerlink" title="通配符和特殊符号"></a>通配符和特殊符号</h3><ul>
<li><p>通配符</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105144730322.png" alt="image-20220105144730322"></p>
</li>
<li><p>特殊符号</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105144744963.png" alt="image-20220105144744963"></p>
</li>
</ul>
<h3 id="数据流重定向"><a href="#数据流重定向" class="headerlink" title="数据流重定向"></a>数据流重定向</h3><h4 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h4><p>​    命令执行的时候需要输入，执行完后需要将数据输出。具体从哪输入和输出到哪则可以进行设置。</p>
<ul>
<li>标准输入（standard input, stdin)：代码为0，使用&lt;或&lt;&lt;</li>
<li>标准输出（standard output, stdout)：代码为1，使用&gt;或&gt;&gt;</li>
<li>标准错误输出（standard error output，stderr)：代码为2，使用2&gt;或2&gt;&gt;</li>
</ul>
<h4 id="数据流输出"><a href="#数据流输出" class="headerlink" title="数据流输出"></a>数据流输出</h4><ul>
<li><p>不同符号的意义</p>
<ul>
<li>1&gt;：以覆盖的方法将正确的数据输出到指定的文件或设备上</li>
<li>1&gt;&gt;：以累计的方法将正确的数据输出到指定的文件或设备上</li>
<li>2&gt;：以覆盖的方法将错误的数据输出到指定的文件或设备上</li>
<li>2&gt;&gt;：以累计的方法将错误的数据输出到指定的文件或设备上</li>
</ul>
</li>
<li><p>常见用法</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">command</span> <span class="token operator">></span> filename1 <span class="token operator"><span class="token file-descriptor important">2</span>></span> filename2 <span class="token comment"># 正确和错误数据分别输出到两个文件</span>

<span class="token builtin class-name">command</span> <span class="token operator">></span> filename <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span> <span class="token comment"># 正确和错误数据分别输出到同一个文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li><p><code>/dev/null</code>垃圾桶</p>
<p>这个黑洞设备可以吃掉任何导向这个设备的信息，即输入这里的信息将被丢弃。</p>
</li>
</ul>
<h4 id="数据流输入"><a href="#数据流输入" class="headerlink" title="数据流输入"></a>数据流输入</h4><p>​    stdin即是将原本需要由键盘输入的数据改由文件内容来代替</p>
<ul>
<li><p><code>&lt;</code></p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">cat</span> <span class="token operator">></span> outfilename <span class="token operator">&lt;</span> inputfilename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105150517867.png" alt="image-20220105150517867"></p>
</li>
<li><p>&lt;&lt;</p>
<p>代表输入结束的意思。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105150546420.png" alt="image-20220105150546420"></p>
</li>
</ul>
<h3 id="多个命令执行的判断条件"><a href="#多个命令执行的判断条件" class="headerlink" title="多个命令执行的判断条件"></a>多个命令执行的判断条件</h3><h4 id="命令回传码"><a href="#命令回传码" class="headerlink" title="命令回传码$?"></a>命令回传码$?</h4><p>​    若一个命令执行的结果为正确，在Linux下面会回传一个**<code>$?=0</code>**</p>
<h4 id="判断条件"><a href="#判断条件" class="headerlink" title="判断条件"></a>判断条件</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105151003619.png" alt="image-20220105151003619"></p>
<p>​    若有多个判断条件，Linux<strong>从左到右</strong>开始进行判断</p>
<h3 id="管道命令"><a href="#管道命令" class="headerlink" title="管道命令"></a>管道命令</h3><p>​    符号是<code>|</code>，将多个命令连接起来进行处理</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105151436691.png" alt="image-20220105151436691"></p>
<p>管道命令在使用时，<strong>每个管道后面的第一个数据一定是“命令”，且这个命令必须要能够接收数据</strong>。</p>
<p>管道命令的注意点：</p>
<ul>
<li>管道命令仅处理<strong>stdout，忽略stderr</strong></li>
<li>管道命令必须接收前一个命令的数据成为stdin来继续处理</li>
</ul>
<p>注意减号<code>-</code>的用途，<strong>在某些命令用到文件名的时候，stdin和stdout可以用<code>-</code>来代替</strong>。</p>
<h4 id="选取命令"><a href="#选取命令" class="headerlink" title="选取命令"></a>选取命令</h4><ul>
<li><p>cut</p>
<p>按自定义方式分割字符串并选取片段</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105151821196.png" alt="image-20220105151821196"></p>
</li>
<li><p>grep</p>
<p>查找输入相关的字符串</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105151953296.png" alt="image-20220105151953296"><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105152001216.png" alt="image-20220105152001216"></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105160248886.png" alt="image-20220105160248886"></p>
</li>
</ul>
<h4 id="排序命令"><a href="#排序命令" class="headerlink" title="排序命令"></a>排序命令</h4><ul>
<li><p>sort</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105152100436.png" alt="image-20220105152100436"></p>
</li>
<li><p>uniq</p>
<p>对输出结果去重处理</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105152156981.png" alt="image-20220105152156981"></p>
</li>
<li><p>wc</p>
<p>统计字符</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105152440567.png" alt="image-20220105152440567"></p>
</li>
</ul>
<h4 id="双向重定向"><a href="#双向重定向" class="headerlink" title="双向重定向"></a>双向重定向</h4><p>​    同时将数据流送到文件与屏幕</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105152614042.png" alt="image-20220105152614042"></p>
<h4 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h4><ul>
<li><p>tr</p>
<p>删除一段信息当中的文字，或是进行文字信息的替换。</p>
<p>后面的字符串可以是<strong>正则表达式</strong></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105152749247.png" alt="image-20220105152749247"><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105152803495.png"></p>
</li>
<li><p>col</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105153105945.png" alt="image-20220105153105945"></p>
</li>
<li><p>join</p>
<p>对比两个文件的数据相关性，并将两个文件当中有相同数据的行相加在一起</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105153216104.png" alt="image-20220105153216104"></p>
</li>
<li><p>paste</p>
<p>直接将两个文件的两行贴在一起</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105153540224.png" alt="image-20220105153540224"></p>
</li>
<li><p>expand</p>
<p>将[tab]转换为空格键</p>
<p>[tab]默认为8个空格</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105153703697.png" alt="image-20220105153703697"></p>
</li>
</ul>
<h4 id="切割命令"><a href="#切割命令" class="headerlink" title="切割命令"></a>切割命令</h4><p>​    将一个大文件依据文件大小或行数来切割为小文件</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105153901791.png" alt="image-20220105153901791"></p>
<h4 id="参数代换"><a href="#参数代换" class="headerlink" title="参数代换"></a>参数代换</h4><p>​    xargs读入stdin的数据，并以空格或断行字符进行分隔为名的参数</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105154026640.png" alt="image-20220105154026640"></p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>​    正则表达式(Regular Expression)是通过一些特殊字符的排列，用以查找、替换、删除一行或多行文字字符串。</p>
<h3 id="基础正则"><a href="#基础正则" class="headerlink" title="基础正则"></a>基础正则</h3><h4 id="语系的设置"><a href="#语系的设置" class="headerlink" title="语系的设置"></a>语系的设置</h4><p>​    不同语系对正则的结果有影响，通常使用C语系即<code>LANG=C</code>，兼容POSIX的标准。其有些特殊的符号如下。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105160112857.png" alt="image-20220105160112857"></p>
<h4 id="基础正则字符表"><a href="#基础正则字符表" class="headerlink" title="基础正则字符表"></a>基础正则字符表</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105160416217.png" alt="image-20220105160416217"><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105160426010.png" alt="image-20220105160426010"></p>
<h3 id="扩展正则"><a href="#扩展正则" class="headerlink" title="扩展正则"></a>扩展正则</h3><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105160844165.png" alt="image-20220105160844165"></p>
<h3 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h3><h4 id="数据CURD工具sed"><a href="#数据CURD工具sed" class="headerlink" title="数据CURD工具sed"></a>数据CURD工具<code>sed</code></h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105160754008.png" alt="image-20220105160754008"><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105160800618.png" alt="image-20220105160800618"></p>
<h4 id="输出格式化工具"><a href="#输出格式化工具" class="headerlink" title="输出格式化工具"></a>输出格式化工具</h4><ul>
<li><p>printf</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105161017356.png" alt="image-20220105161017356"></p>
</li>
<li><p>awk</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">awk</span> <span class="token string">'条件类型1&#123;动作1&#125; 条件类型2&#123;动作2&#125; ...'</span> filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105161841639.png" alt="image-20220105161841639"></p>
<ul>
<li><p>相比于sed常常处理整行数据，awk可以分段处理，非常适合处理小型的数据处理。</p>
</li>
<li><p>awk可以后接文件处理，也可以处理前一个命令的stdout.</p>
</li>
<li><p>处理的每一行的字段内的数据，默认以空格键或[tab]键进行分隔。</p>
</li>
<li><p>每一行的字段都有变量名<code>$colum</code>，colum是第几列，其中<code>$0</code>表示整行。</p>
</li>
<li><p>awk的内置参数：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105162023997.png" alt="image-20220105162023997"></p>
<ul>
<li>awk的条件逻辑运算符</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105162144128.png" alt="image-20220105162144128"></p>
<ul>
<li>在awk中，shell变量可以直接使用，不用加上$符号</li>
</ul>
</li>
</ul>
<h2 id="Shell-Script"><a href="#Shell-Script" class="headerlink" title="Shell Script"></a>Shell Script</h2><h3 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h3><p>​    shell script 是利用shell的功能所写的一个“程序”，这个程序是使用纯文本文件，将一些shell的语法与命令（含外部命令）写在里面，搭配正则表达式、管道命令与数据流重定向等功能，以达到我们所想要的处理目的。</p>
<p>​    shell script是直接利用shell与相关工具，所以不需要编辑即可执行。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h4><ol>
<li>命令的执行是从上而下，从左而右地分析与执行</li>
<li>空白行会被忽略掉，并且[tab]键所得到的空白同样是为空格键</li>
<li>读取到一个Enter符号（CR），就尝试开始执行改行命令</li>
<li>一行内容太多，可以使用<code>\[Enter]</code>换行</li>
<li><code>#</code>视为批注</li>
</ol>
<h4 id="执行命令的方法"><a href="#执行命令的方法" class="headerlink" title="执行命令的方法"></a>执行命令的方法</h4><p>​    执行sh文件必须具备可读与可执行(<code>rx</code>)权限！</p>
<p>​    分为执行命令的方式有两大种，其中第一种又分3种。</p>
<ul>
<li><p>使用bash</p>
<pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">bash shell.sh
或
sh shell.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li>绝对路径执行</li>
<li>相对路径执行</li>
<li>放置到PATH或其已经写入的目录下，直接输入sh文件名执行</li>
</ul>
<p><strong>这种方式执行，script会使用一个新的<code>bash</code>环境来执行命令，即script是在bash的子进程执行的。所以在script中设置的变量不会传回到父进程中。</strong></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105165748382.png" alt="image-20220105165748382"></p>
</li>
<li><p>利用source或<code>.</code></p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">source</span> shell.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>这种方式执行，script直接在父进程中执行，所以script中定义的变量会生效</strong>。</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105165853548.png" alt="image-20220105165853548"></p>
</li>
</ul>
<h4 id="sh文件分析"><a href="#sh文件分析" class="headerlink" title="sh文件分析"></a>sh文件分析</h4><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105164206712.png" alt="image-20220105164206712"></p>
<ul>
<li><p>第一部分，声明，说明这个script使用的shell名称</p>
<p>bash在执行的时候会加载相关的配置文件，一般是non-login shell的<code>~/.bashrc</code>。</p>
</li>
<li><p>第二部分，批注，程序内容的说明</p>
</li>
<li><p>第三部分，主要环境变量的说明</p>
<p>一般来说声明PATH和LANG，以使用外部命令</p>
</li>
<li><p>第4部分，主要程序部分</p>
</li>
<li><p>第5部分，告知执行结果</p>
<p><code>exit n表示中断程序并回传一个值个系统。后面的命令使用</code>$?`即可得到这个值。</p>
</li>
</ul>
<h4 id="sh的默认变量"><a href="#sh的默认变量" class="headerlink" title="sh的默认变量"></a>sh的默认变量</h4><ul>
<li><p>使用特殊符号，读取sh文件后接的输入参数。</p>
<p>​    按整条命令的参数顺序，依次为<code>$0</code>、<code>$1</code>等（从bash/sh的下一个参数开始）</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106105950275.png" alt="image-20220106105950275"></p>
</li>
<li><p>一些特殊符号：</p>
<ul>
<li><code>$#</code>，表示sh文件后面接的参数的个数</li>
<li><code>$@</code>，表示sh文件的所有参数</li>
<li><code>$*</code>，表示<code>$0c$1c$2</code>，其中c为分隔符，默认为空格键</li>
</ul>
</li>
<li><p><code>shift</code>，造成参数变量号码偏移</p>
</li>
</ul>
<h3 id="逻辑语法"><a href="#逻辑语法" class="headerlink" title="逻辑语法"></a>逻辑语法</h3><h4 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h4><p><strong>两个可以写在条件里面的判断式</strong>:</p>
<ul>
<li><p>测试命令Test</p>
<p>检测某个文件是否存在、是否有特定属性权限、基本大小判断等等。<img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106104417160.png" alt="image-20220106104417160"><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106104450709.png" alt="image-20220106104450709"></p>
</li>
<li><p>判读符号[]</p>
<p>返回结果只有真和假，可以结合<code>&amp;&amp;</code>和<code>||</code>使用</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106105056317.png" alt="image-20220106105056317"></p>
<p><strong>一些注意事项：</strong></p>
<ul>
<li>中括号的两端需要有空格符来分割</li>
<li>中括号内的每个组件都需要有空格键来分隔</li>
<li>中括号内的变量，最好都以双引号括起来</li>
<li>中括号内的常量，最好都以单或双引号括起来</li>
</ul>
<p><strong>一些参数：</strong></p>
<ul>
<li><code>-o</code>参数，在中括号里面相当于“或”</li>
</ul>
</li>
</ul>
<p><strong>下面就是具体的条件表达式</strong>:</p>
<ul>
<li><p><code>if...then</code></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106110644574.png" alt="image-20220106110644574"></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106110719404.png" alt="image-20220106110719404"></p>
</li>
<li><p><code>case..esac</code></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106110834908.png" alt="image-20220106110834908"></p>
<p>一个列子：</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106110856307.png" alt="image-20220106110856307"></p>
</li>
</ul>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p><em>不定循环</em>：</p>
<ul>
<li><p><code>while do done</code></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106111728580.png" alt="image-20220106111728580"></p>
</li>
<li><p><code>until do done</code></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106111744960.png" alt="image-20220106111744960"></p>
</li>
</ul>
<p><em>固定循环</em>：</p>
<ul>
<li><p><code>for...do...done</code></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106111858866.png" alt="image-20220106111858866"></p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106111937902.png" alt="image-20220106111937902"></p>
</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li><p>语法</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106111103302.png" alt="image-20220106111103302"></p>
<p>由于shell script的执行方式是由上而下、由左而右，所以<strong>function的设置一定要在程序的最前面</strong>。</p>
</li>
<li><p>内置参数</p>
<p>函数名称用<code>$0</code>表示，后续节点变量依次用<code>$1</code>、<code>$2</code>等表示。</p>
<p>后面接参数的形式是：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">fname opt1 opt2 opt3 <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<h3 id="shell-script的追踪与调试"><a href="#shell-script的追踪与调试" class="headerlink" title="shell script的追踪与调试"></a>shell script的追踪与调试</h3><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220106112036406.png" alt="image-20220106112036406"></p>
<h2 id="Shell其他相关命令"><a href="#Shell其他相关命令" class="headerlink" title="Shell其他相关命令"></a>Shell其他相关命令</h2><h3 id="Shell资源限制命令ulimit"><a href="#Shell资源限制命令ulimit" class="headerlink" title="Shell资源限制命令ulimit"></a>Shell资源限制命令ulimit</h3><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220103172454549.png" alt="image-20220103172454549"></p>
<h3 id="查看历史输入命令history"><a href="#查看历史输入命令history" class="headerlink" title="查看历史输入命令history"></a>查看历史输入命令history</h3><p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105133021865.png" alt="image-20220105133021865"></p>
<ul>
<li>历史命令记录在<code>~/.bash_history</code>文件中</li>
<li><code>~/.bash_history</code>记录的命令个数和bash的<code>HISTSIZE</code>变量有关。</li>
</ul>
<h3 id="设置终端机环境stty-set"><a href="#设置终端机环境stty-set" class="headerlink" title="设置终端机环境stty/set"></a>设置终端机环境stty/set</h3><ul>
<li>设置按键代表的含义等</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105144130419.png" alt="image-20220105144130419"></p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">stty <span class="token keyword">function</span> Key
<span class="token comment">#例如： stty erase ^h，^代表[Ctrl]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li>设置Bash的终端机环境</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105144453394.png" alt="image-20220105144453394"></p>
<h3 id="文件比较命令diff-cmp-patch"><a href="#文件比较命令diff-cmp-patch" class="headerlink" title="文件比较命令diff/cmp/patch"></a>文件比较命令diff/cmp/patch</h3><ul>
<li><p>diff</p>
<p>以行为单位进行文件比较</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105162630991.png" alt="image-20220105162630991"></p>
</li>
<li><p>cmp</p>
<p>利用字节为单位进行比较，可以比较二进制文件</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105162745735.png" alt="image-20220105162745735"></p>
</li>
<li><p>patch</p>
<p><img src="https://raw.githubusercontent.com/Jason-QianHao/picgo-imgs/main/img/image-20220105162854512.png" alt="image-20220105162854512"></p>
</li>
</ul>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">小小千千</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jason-qianhao.github.io/2021/12/16/niao-ge-de-linux-si-fang-cai-ji-chu-xue-xi-pian-bi-ji/">https://jason-qianhao.github.io/2021/12/16/niao-ge-de-linux-si-fang-cai-ji-chu-xue-xi-pian-bi-ji/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">小小千千</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                    <span class="chip bg-color">操作系统</span>
                                </a>
                            
                                <a href="/tags/Linux/">
                                    <span class="chip bg-color">Linux</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'Si5PlwXoOsczw9YMDIGjYPSK-gzGzoHsz',
        appKey: 'stI6rxYdK6PXYnmGVxx1JHML',
        notify: '' === 'true',
        verify: 'true' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '在这里评论吧！填写真实邮箱可以获得回复通知哦'
    });
</script>

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/01/12/niao-ge-de-linux-si-fang-cai-fu-wu-qi-pian-bi-ji/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/32.jpg" class="responsive-img" alt="《鸟哥的LINUX私房菜_服务器篇》笔记">
                        
                        <span class="card-title">《鸟哥的LINUX私房菜_服务器篇》笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-01-12
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-category">
                                    操作系统
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                        <span class="chip bg-color">操作系统</span>
                    </a>
                    
                    <a href="/tags/Linux/">
                        <span class="chip bg-color">Linux</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/12/13/chang-jian-ri-zhi-kuang-jia/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/11.jpg" class="responsive-img" alt="常见日志框架">
                        
                        <span class="card-title">常见日志框架</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-12-13
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Log/" class="post-category">
                                    Log
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Log/">
                        <span class="chip bg-color">Log</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1, h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021-2022</span>
            
            <span id="year">2021</span>
            <a href="/about" target="_blank">小小千千</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">455.9k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/Jason-QianHao" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:qianhao_cs@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=404836248" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 404836248" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>

---
title: Go学习笔记
tags: Go
---

# Go学习笔记

# 概念

- Go 是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易。

- Go 语言被设计成一门**应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言**。对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。

- 语言特色
  - 简洁、快速、安全
  - 并行、有趣、开源
  - 内存管理、数组安全、编译迅速

# 基本语法

## 语法结构

- 包含

  - 包声明

    必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。

  - 引入包

  - 函数

  - 变量

  - 语句 & 表达式

    当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）

  - 注释

  ```go
  // demo
  package main
  
  import "fmt"
  
  func main() {
     /* 这是我的第一个简单的程序 */
     fmt.Println("Hello, World!")
  }
  ```

- 运行

  - *go run hello.go*运行文件
  - **go build** hello.go命令来生成二进制文件（可执行文件）

  ```go
  $ go build hello.go 
  $ ls
  hello    hello.go
  $ ./hello 
  Hello, World!
  ```

- 行分隔符
  在 Go 程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。

  如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。
  
- 格式化输出

  Go 语言中使用 **fmt.Sprintf** 格式化字符串并赋值给新串：

  ```go
  package main
  
  import (
      "fmt"
  )
  
  func main() {
     // %d 表示整型数字，%s 表示字符串
      var stockcode=123
      var enddate="2020-12-31"
      var url="Code=%d&endDate=%s"
      var target_url=fmt.Sprintf(url,stockcode,enddate)
      fmt.Println(target_url)
  }
  
  // output: Code=123&endDate=2020-12-31
  ```

## 数据类型

### 分类

| 序号 | 类型和描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | **布尔型** <br />布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。 |
| 2    | **数字类型** <br />整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。<br />Go 也有基于架构的类型，例如：int8、uint8 等 |
| 3    | **字符串类型:** <br />- 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。<br />- **Go 语言的字符串可以通过 “+”实现** |
| 4    | **派生类型:** <br />(a) 指针类型（Pointer）<br />(b) 数组类型<br />(c) 结构化类型(struct)<br />(d) Channel 类型<br />(e) 函数类型<br />(f) 切片类型<br />(g) 接口类型（interface）<br />(h) Map 类型 |

详细参考：[go数据类型](https://www.runoob.com/go/go-data-types.html)

### 变量

声明变量的一般形式是使用` var` 关键字：`var identifier1, identifier2 type`

```go
// demo
package main
import "fmt"
func main() {
    var a string = "Runoob"
    fmt.Println(a)

    var b, c int = 1, 2
    fmt.Println(b, c)
}
```

声明变量有以下几种方式：

- **指定变量类型，如果没有初始化，则变量默认为零值**。

```go
//var v_name v_type
//v_name = value
// 没有初始化就为零值
var b int
```

- **根据值自行判定变量类型。**

```go
// var v_name = value
var d = true
```

- **使用 \**:=\** 声明变量**(使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值)

`intVal := 1 `相等于：

```go
var intVal int 
intVal =1 
```

 出现在 `:= `左侧的变量不应该是已经被声明过的，否则会导致编译错误

- 因式分解法(一般用于声明全局变量)

  ```go
  var (
      vname1 v_type1
      vname2 v_type2
  )
  ```

**一些小技巧**

- 并行 或 同时 赋值

  ```go
  a, b, c := 5, 7, "abc"
  ```

- 如果你想要交换两个变量的值，则可以简单地使用 **a, b = b, a**，两个变量的类型必须是相同。

- 空白标识符 _ 也被用于抛弃值，如值 5 在：_, b = 5, 7 中被抛弃。_

   实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。

### 值类型和引用类型

- 值类型

所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值：

![4.4.2_fig4.1](https://www.runoob.com/wp-content/uploads/2015/06/4.4.2_fig4.1.jpgrawtrue)

当使用等号 `=` 将一个变量的值赋值给另一个变量时，如：`j = i`，实际上是在内存中将 i 的值进行了拷贝：

![4.4.2_fig4.2](https://www.runoob.com/wp-content/uploads/2015/06/4.4.2_fig4.2.jpgrawtrue)

你可以通过 &i 来获取变量 i 的内存地址，例如：0xf840000040（每次的地址都可能不一样）。值类型的变量的值存储在栈中。

内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也可能不同。

更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。

- 引用类型

一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。

![4.4.2_fig4.3](https://www.runoob.com/wp-content/uploads/2015/06/4.4.2_fig4.3.jpgrawtrue)

这个内存地址称之为指针，这个指针实际上也被存在另外的某一个值中。

同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。

当使用赋值语句 r2 = r1 时，只有引用（地址）被复制。

如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响。

### 常量

#### 概念

常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。

#### 语法

- 常量的定义格式：

```go
const identifier [type] = value
```

- 多个相同类型的声明可以简写为：

```
const c_name1, c_name2 = value1, value2
```

- 常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过。

  ```go
  package main
  
  import "unsafe"
  const (
      a = "abc"
      b = len(a)
      c = unsafe.Sizeof(a)
  )
  
  func main(){
      println(a, b, c)
  }
  ```

#### iota

iota，特殊常量，可以认为是一个可以被编译器修改的常量。iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。

```go
package main

import "fmt"

func main() {
    const (
            a = iota   //0
            b          //1
            c          //2
            d = "ha"   //独立值，iota += 1
            e          //"ha"   iota += 1
            f = 100    //iota +=1
            g          //100  iota +=1
            h = iota   //7,恢复计数
            i          //8
    )
    fmt.Println(a,b,c,d,e,f,g,h,i)
}
//output 0 1 2 ha ha 100 100 7 8
```

```go
package main

import "fmt"
const (
    i=1<<iota
    j=3<<iota
    k
    l
)

func main() {
    fmt.Println("i=",i)
    fmt.Println("j=",j)
    fmt.Println("k=",k)
    fmt.Println("l=",l)
}
/*output
i= 1
j= 6
k= 12
l= 24
*/
```

## 运算符

- 算术运算符

  | 运算符 | 描述 | 实例               |
  | :----- | :--- | :----------------- |
  | +      | 相加 | A + B 输出结果 30  |
  | -      | 相减 | A - B 输出结果 -10 |
  | *      | 相乘 | A * B 输出结果 200 |
  | /      | 相除 | B / A 输出结果 2   |
  | %      | 求余 | B % A 输出结果 0   |
  | ++     | 自增 | A++ 输出结果 11    |
  | --     | 自减 | A-- 输出结果 9     |

- 关系运算符

  | 运算符 | 描述                                                         | 实例              |
  | :----- | :----------------------------------------------------------- | :---------------- |
  | ==     | 检查两个值是否相等，如果相等返回 True 否则返回 False。       | (A == B) 为 False |
  | !=     | 检查两个值是否不相等，如果不相等返回 True 否则返回 False。   | (A != B) 为 True  |
  | >      | 检查左边值是否大于右边值，如果是返回 True 否则返回 False。   | (A > B) 为 False  |
  | <      | 检查左边值是否小于右边值，如果是返回 True 否则返回 False。   | (A < B) 为 True   |
  | >=     | 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。 | (A >= B) 为 False |
  | <=     | 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。 | (A <= B) 为 True  |

- 逻辑运算符

  | 运算符 | 描述                                                         | 实例               |
  | :----- | :----------------------------------------------------------- | :----------------- |
  | &&     | 逻辑 AND 运算符。 如果两边的操作数都是 True，则条件 True，否则为 False。 | (A && B) 为 False  |
  | \|\|   | 逻辑 OR 运算符。 如果两边的操作数有一个 True，则条件 True，否则为 False。 | (A \|\| B) 为 True |
  | !      | 逻辑 NOT 运算符。 如果条件为 True，则逻辑 NOT 条件 False，否则为 True。 | !(A && B) 为 Tru   |

- 位运算符

  | 运算符 | 描述                                                         | 实例                                   |
  | :----- | :----------------------------------------------------------- | :------------------------------------- |
  | &      | 按位与运算符"&"是双目运算符。 其功能是参与运算的两数各对应的二进位相与。 | (A & B) 结果为 12, 二进制为 0000 1100  |
  | \|     | 按位或运算符"\|"是双目运算符。 其功能是参与运算的两数各对应的二进位相或 | (A \| B) 结果为 61, 二进制为 0011 1101 |
  | ^      | 按位异或运算符"^"是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 | (A ^ B) 结果为 49, 二进制为 0011 0001  |
  | <<     | 左移运算符"<<"是双目运算符。左移n位就是乘以2的n次方。 其功能把"<<"左边的运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，高位丢弃，低位补0。 | A << 2 结果为 240 ，二进制为 1111 0000 |
  | >>     | 右移运算符">>"是双目运算符。右移n位就是除以2的n次方。 其功能是把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数。 | A >> 2                                 |

- 赋值运算符

  | 运算符 | 描述                                           | 实例                                  |
  | :----- | :--------------------------------------------- | :------------------------------------ |
  | =      | 简单的赋值运算符，将一个表达式的值赋给一个左值 | C = A + B 将 A + B 表达式结果赋值给 C |
  | +=     | 相加后再赋值                                   | C += A 等于 C = C + A                 |
  | -=     | 相减后再赋值                                   | C -= A 等于 C = C - A                 |
  | *=     | 相乘后再赋值                                   | C *= A 等于 C = C * A                 |
  | /=     | 相除后再赋值                                   | C /= A 等于 C = C / A                 |
  | %=     | 求余后再赋值                                   | C %= A 等于 C = C % A                 |
  | <<=    | 左移后赋值                                     | C <<= 2 等于 C = C << 2               |
  | >>=    | 右移后赋值                                     | C >>= 2 等于 C = C >> 2               |
  | &=     | 按位与后赋值                                   | C &= 2 等于 C = C & 2                 |
  | ^=     | 按位异或后赋值                                 | C ^= 2 等于 C = C ^ 2                 |
  | \|=    | 按位或后赋值                                   | C \|= 2 等于 C = C \| 2               |

- 其他

  | 运算符 | 描述             | 实例                       |
  | :----- | :--------------- | :------------------------- |
  | &      | 返回变量存储地址 | &a; 将给出变量的实际地址。 |
  | *      | 指针变量。       | *a; 是一个指针变量         |

**运算符优先级**

| 优先级 | 运算符           |
| :----- | :--------------- |
| 5      | * / % << >> & &^ |
| 4      | + - \| ^         |
| 3      | == != < <= > >=  |
| 2      | &&               |
| 1      | \|\|             |

## 条件控制

| 语句                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [if 语句](https://www.runoob.com/go/go-if-statement.html)    | **if 语句** 由一个布尔表达式后紧跟一个或多个语句组成。       |
| [if...else 语句](https://www.runoob.com/go/go-if-else-statement.html) | **if 语句** 后可以使用可选的 **else 语句**, else 语句中的表达式在布尔表达式为 false 时执行。 |
| [if 嵌套语句](https://www.runoob.com/go/go-nested-if-statements.html) | 你可以在 **if** 或 **else if** 语句中嵌入一个或多个 **if** 或 **else if** 语句。 |
| [switch 语句](https://www.runoob.com/go/go-switch-statement.html) | **switch** 语句用于基于不同条件执行不同动作。                |
| [select 语句](https://www.runoob.com/go/go-select-statement.html) | **select** 语句类似于 **switch** 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。 |

| 循环类型                                                   | 描述                                 |
| :--------------------------------------------------------- | :----------------------------------- |
| [for 循环](https://www.runoob.com/go/go-for-loop.html)     | 重复执行语句块                       |
| [循环嵌套](https://www.runoob.com/go/go-nested-loops.html) | 在 for 循环中嵌套一个或多个 for 循环 |

| [break 语句](https://www.runoob.com/go/go-break-statement.html) | 经常用于中断当前 for 循环或跳出 switch 语句      |
| ------------------------------------------------------------ | ------------------------------------------------ |
| [continue 语句](https://www.runoob.com/go/go-continue-statement.html) | 跳过当前循环的剩余语句，然后继续进行下一轮循环。 |
| [goto 语句](https://www.runoob.com/go/go-goto-statement.html) | 将控制转移到被标记的语句。                       |

## 函数

### 函数定义

```go
func function_name( [parameter list] ) [return_types] {
   函数体
}
```

- 返回值可以有多个

  ```go
  package main
  
  import "fmt"
  
  func swap(x, y string) (string, string) {
     return y, x
  }
  
  func main() {
     a, b := swap("Google", "Runoob")
     fmt.Println(a, b)
  }
  ```

- Go 语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑。

### 传参方式

| 传递类型                                                     | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [值传递](https://www.runoob.com/go/go-function-call-by-value.html) | 值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。 |
| [引用传递](https://www.runoob.com/go/go-function-call-by-reference.html) | 引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。 |

### 函数用法

| 函数用法                                                     | 描述                                     |
| :----------------------------------------------------------- | :--------------------------------------- |
| [函数作为另外一个函数的实参](https://www.runoob.com/go/go-function-as-values.html) | 函数定义后可作为另外一个函数的实参数传入 |
| [闭包](https://www.runoob.com/go/go-function-closures.html)  | 闭包是匿名函数，可在动态编程中使用       |
| [方法](https://www.runoob.com/go/go-method.html)             | 方法就是一个包含了接受者的函数           |

# 数据结构

## 数组

### 语法结构

- 一维数组

```go
var variable_name [SIZE] variable_type
// example
var balance [10] float32
```

- 多维数组

```go
var variable_name [SIZE1][SIZE2]...[SIZEN] variable_type
// example;
var threedim [5][10][4]int
```

### 初始化

- 声明数组的同时快速初始化数组

  ```go
  balance := [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
  ```

- 数组长度不确定，可以使用 **...** 代替数组的长度

  ```go
  balance := [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
  ```

- 通过指定下标来初始化元素

  ```go
  //  将索引为 1 和 3 的元素初始化
  balance := [5]float32{1:2.0,3:7.0}
  ```

### 访问

```go
var salary float32 = balance[9]
```

### 数组传参

- 不设定数组大小

  ```go
  void myFunction(param []int)
  ```

- 设定数组大小

  ```go
  void myFunction(param [10]int)
  ```

## 指针

### 概念

一个指针变量指向了一个值的内存地址。

- 语法

```go
var var_name *var-type
```

```go
var ip *int        /* 指向整型*/
var fp *float32    /* 指向浮点型 */
```

```go
// demo
package main

import "fmt"

func main() {
   var a int= 20   /* 声明实际变量 */
   var ip *int        /* 声明指针变量 */

   ip = &a  /* 指针变量的存储地址 */

   fmt.Printf("a 变量的地址是: %x\n", &a  )

   /* 指针变量的存储地址 */
   fmt.Printf("ip 变量储存的指针地址: %x\n", ip )

   /* 使用指针访问值 */
   fmt.Printf("*ip 变量的值: %d\n", *ip )
}
```

### 空指针

当一个指针被定义后没有分配到任何变量时，它的值为 nil。

nil 指针也称为空指针。

nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。
